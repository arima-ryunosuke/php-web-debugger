<?php
# Don't touch this code. This is auto generated.
namespace ryunosuke\WebDebugger;

if (!defined('ryunosuke\\WebDebugger\\IS_OWNSELF')) {
    define('ryunosuke\\WebDebugger\\IS_OWNSELF', 2);
}

if (!defined('ryunosuke\\WebDebugger\\IS_PUBLIC')) {
    define('ryunosuke\\WebDebugger\\IS_PUBLIC', 4);
}

if (!defined('ryunosuke\\WebDebugger\\IS_PROTECTED')) {
    define('ryunosuke\\WebDebugger\\IS_PROTECTED', 8);
}

if (!defined('ryunosuke\\WebDebugger\\IS_PRIVATE')) {
    define('ryunosuke\\WebDebugger\\IS_PRIVATE', 16);
}

if (!defined('ryunosuke\\WebDebugger\\JP_ERA')) {
    define('ryunosuke\\WebDebugger\\JP_ERA', [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined('ryunosuke\\WebDebugger\\GLOB_RECURSIVE')) {
    define('ryunosuke\\WebDebugger\\GLOB_RECURSIVE', 65536);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_MAX_DEPTH')) {
    define('ryunosuke\\WebDebugger\\JSON_MAX_DEPTH', -1);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_INDENT')) {
    define('ryunosuke\\WebDebugger\\JSON_INDENT', -71);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_CLOSURE')) {
    define('ryunosuke\\WebDebugger\\JSON_CLOSURE', -72);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_NEST_LEVEL')) {
    define('ryunosuke\\WebDebugger\\JSON_NEST_LEVEL', -73);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_INLINE_LEVEL')) {
    define('ryunosuke\\WebDebugger\\JSON_INLINE_LEVEL', -74);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_INLINE_SCALARLIST')) {
    define('ryunosuke\\WebDebugger\\JSON_INLINE_SCALARLIST', -75);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_ES5')) {
    define('ryunosuke\\WebDebugger\\JSON_ES5', -100);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_INT_AS_STRING')) {
    define('ryunosuke\\WebDebugger\\JSON_INT_AS_STRING', -101);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_FLOAT_AS_STRING')) {
    define('ryunosuke\\WebDebugger\\JSON_FLOAT_AS_STRING', -102);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_TRAILING_COMMA')) {
    define('ryunosuke\\WebDebugger\\JSON_TRAILING_COMMA', -103);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_COMMENT_PREFIX')) {
    define('ryunosuke\\WebDebugger\\JSON_COMMENT_PREFIX', -104);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_TEMPLATE_LITERAL')) {
    define('ryunosuke\\WebDebugger\\JSON_TEMPLATE_LITERAL', -105);
}

if (!defined('ryunosuke\\WebDebugger\\JSON_BARE_AS_STRING')) {
    define('ryunosuke\\WebDebugger\\JSON_BARE_AS_STRING', -106);
}

if (!defined('ryunosuke\\WebDebugger\\TOKEN_NAME')) {
    define('ryunosuke\\WebDebugger\\TOKEN_NAME', 2);
}

if (!defined('ryunosuke\\WebDebugger\\SI_UNITS')) {
    define('ryunosuke\\WebDebugger\\SI_UNITS', [
        -8 => ["y"],
        -7 => ["z"],
        -6 => ["a"],
        -5 => ["f"],
        -4 => ["p"],
        -3 => ["n"],
        -2 => ["u", "μ", "µ"],
        -1 => ["m"],
        0  => [],
        1  => ["k", "K"],
        2  => ["M"],
        3  => ["G"],
        4  => ["T"],
        5  => ["P"],
        6  => ["E"],
        7  => ["Z"],
        8  => ["Y"],
    ]);
}

if (!defined('ryunosuke\\WebDebugger\\SORT_STRICT')) {
    define('ryunosuke\\WebDebugger\\SORT_STRICT', 256);
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_all') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_all'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_all')) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_all([true, true]))->isTrue();
     * that(array_all([true, false]))->isFalse();
     * that(array_all([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_all($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_any') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_any'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_any')) {
    /**
     * 全要素が false になるなら false を返す（1つでも true なら true を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_any([true, true]))->isTrue();
     * that(array_any([true, false]))->isTrue();
     * that(array_any([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が false なら false
     */
    function array_any($array, $callback = null, $default = false)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if ($callback($v, $k, $n++)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_each') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_each'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_each')) {
    /**
     * array_reduce の参照版（のようなもの）
     *
     * 配列をループで回し、その途中経過、値、キー、連番をコールバック引数で渡して最終的な結果を返り値として返す。
     * array_reduce と少し似てるが、下記の点が異なる。
     *
     * - いわゆる $carry は返り値で表すのではなく、参照引数で表す
     * - 値だけでなくキー、連番も渡ってくる
     * - 巨大配列の場合でも速度劣化が少ない（array_reduce に巨大配列を渡すと実用にならないレベルで遅くなる）
     *
     * $callback の引数は `($value, $key, $n)` （$n はキーとは関係がない 0 ～ 要素数-1 の通し連番）。
     *
     * 返り値ではなく参照引数なので return する必要はない（ワンライナーが書きやすくなる）。
     * 返り値が空くのでループ制御に用いる。
     * 今のところ $callback が false を返すとそこで break するのみ。
     *
     * 第3引数を省略した場合、**クロージャの第1引数のデフォルト値が使われる**。
     * これは特筆すべき動作で、不格好な第3引数を完全に省略することができる（サンプルコードを参照）。
     * ただし「php の文法違反（今のところエラーにはならないし、全てにデフォルト値をつければ一応回避可能）」「リフレクションを使う（ほんの少し遅くなる）」などの弊害が有るので推奨はしない。
     * （ただ、「意図していることをコードで表す」といった観点ではこの記法の方が正しいとも思う）。
     *
     * Example:
     * ```php
     * // 全要素を文字列的に足し合わせる
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry .= $v;}, ''))->isSame('12345');
     * // 値をキーにして要素を2乗値にする
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry[$v] = $v * $v;}, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     *     4 => 16,
     *     5 => 25,
     * ]);
     * // 上記と同じ。ただし、3 で break する
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v, $k){
     *     if ($k === 3) return false;
     *     $carry[$v] = $v * $v;
     * }, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     * ]);
     *
     * // 下記は完全に同じ（第3引数の代わりにデフォルト引数を使っている）
     * that(array_each([1, 2, 3], function (&$carry = [], $v = null) {
     *         $carry[$v] = $v * $v;
     *     }))->isSame(array_each([1, 2, 3], function (&$carry, $v) {
     *         $carry[$v] = $v * $v;
     *     }, [])
     *     // 個人的に↑のようなぶら下がり引数があまり好きではない（クロージャを最後の引数にしたい）
     * );
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ。(&$carry, $key, $value) を受ける
     * @param mixed $default ループの最初や空の場合に適用される値
     * @return mixed each した結果
     */
    function array_each($array, $callback, $default = null)
    {
        if (func_num_args() === 2) {
            /** @var \ReflectionFunction $ref */
            $ref = reflect_callable($callback);
            $params = $ref->getParameters();
            if ($params[0]->isDefaultValueAvailable()) {
                $default = $params[0]->getDefaultValue();
            }
        }

        $n = 0;
        foreach ($array as $k => $v) {
            $return = $callback($default, $v, $k, $n++);
            if ($return === false) {
                break;
            }
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_find') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_find'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_find')) {
    /**
     * array_search のクロージャ版のようなもの
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキーを返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最初に見つかったキーを返す
     * that(array_find(['a', '8', '9'], 'ctype_digit'))->isSame(1);
     * that(array_find(['a', 'b', 'b'], fn($v) => $v === 'b'))->isSame(1);
     * // 最初に見つかったコールバック結果を返す（最初の数字の2乗を返す）
     * $ifnumeric2power = fn($v) => ctype_digit($v) ? $v * $v : false;
     * that(array_find(['a', '8', '9'], $ifnumeric2power, false))->isSame(64);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら false
     */
    function array_find($array, $callback, $is_key = true)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            $result = $callback($v, $k, $n++);
            if ($result) {
                if ($is_key) {
                    return $k;
                }
                return $result;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_keys_exist') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_keys_exist'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_keys_exist')) {
    /**
     * array_key_exists の複数版
     *
     * 指定キーが全て存在するなら true を返す。
     * 配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。
     *
     * $keys に空を与えると例外を投げる。
     * $keys に配列を与えるとキーで潜ってチェックする（Example 参照）。
     *
     * Example:
     * ```php
     * // すべて含むので true
     * that(array_keys_exist(['a', 'b', 'c'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isTrue();
     * // N は含まないので false
     * that(array_keys_exist(['a', 'b', 'N'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isFalse();
     * // 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
     * that(array_keys_exist(['a', 'x' => ['x1', 'x2']], ['a' => 'A', 'x' => ['x1' => 'X1', 'x2' => 'X2']]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|string $keys 調べるキー
     * @param array|\ArrayAccess $array 調べる配列
     * @return bool 指定キーが全て存在するなら true
     */
    function array_keys_exist($keys, $array)
    {
        $keys = is_iterable($keys) ? $keys : [$keys];
        if (is_empty($keys)) {
            throw new \InvalidArgumentException('$keys is empty.');
        }

        $is_arrayaccess = $array instanceof \ArrayAccess;

        foreach ($keys as $k => $key) {
            if (is_array($key)) {
                // まずそのキーをチェックして
                if (!array_keys_exist($k, $array)) {
                    return false;
                }
                // あるなら再帰する
                if (!array_keys_exist($key, $array[$k])) {
                    return false;
                }
            }
            elseif ($is_arrayaccess) {
                if (!$array->offsetExists($key)) {
                    return false;
                }
            }
            elseif (!array_key_exists($key, $array)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_kmap') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_kmap'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_kmap')) {
    /**
     * キーも渡ってくる array_map
     *
     * `array_map($callback, $array, array_keys($array))` とほとんど変わりはない。
     * 違いは下記。
     *
     * - 引数の順番が異なる（$array が先）
     * - キーが死なない（array_map は複数配列を与えるとキーが死ぬ）
     * - 配列だけでなく Traversable も受け入れる
     * - callback の第3引数に 0 からの連番が渡ってくる
     *
     * Example:
     * ```php
     * // キー・値をくっつけるシンプルな例
     * that(array_kmap([
     *     'k1' => 'v1',
     *     'k2' => 'v2',
     *     'k3' => 'v3',
     * ], fn($v, $k) => "$k:$v"))->isSame([
     *     'k1' => 'k1:v1',
     *     'k2' => 'k2:v2',
     *     'k3' => 'k3:v3',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @return array $callback を通した新しい配列
     */
    function array_kmap($array, $callback)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        $result = [];
        foreach ($array as $k => $v) {
            $result[$k] = $callback($v, $k, $n++);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_lookup') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_lookup'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_lookup')) {
    /**
     * キー保存可能な array_column
     *
     * array_column は キーを保存することが出来ないが、この関数は引数を2つだけ与えるとキーはそのままで array_column 相当の配列を返す。
     * 逆に第3引数にクロージャを与えるとその結果をキーにすることが出来る。
     *
     * Example:
     * ```php
     * $array = [
     *     11 => ['id' => 1, 'name' => 'name1'],
     *     12 => ['id' => 2, 'name' => 'name2'],
     *     13 => ['id' => 3, 'name' => 'name3'],
     * ];
     * // 第3引数を渡せば array_column と全く同じ
     * that(array_lookup($array, 'name', 'id'))->isSame(array_column($array, 'name', 'id'));
     * that(array_lookup($array, 'name', null))->isSame(array_column($array, 'name', null));
     * // 省略すればキーが保存される
     * that(array_lookup($array, 'name'))->isSame([
     *     11 => 'name1',
     *     12 => 'name2',
     *     13 => 'name3',
     * ]);
     * // クロージャを指定すればキーが生成される
     * that(array_lookup($array, 'name', fn($v, $k) => $k * 2))->isSame([
     *     22 => 'name1',
     *     24 => 'name2',
     *     26 => 'name3',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|null $column_key 値となるキー
     * @param string|\Closure|null $index_key キーとなるキー
     * @return array 新しい配列
     */
    function array_lookup($array, $column_key = null, $index_key = null)
    {
        $array = arrayval($array, false);

        if ($index_key instanceof \Closure) {
            return array_combine(array_kmap($array, $index_key), array_column($array, $column_key));
        }
        if (func_num_args() === 3) {
            return array_column($array, $column_key, $index_key);
        }
        return array_combine(array_keys($array), array_column($array, $column_key));
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_map_method') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_map_method'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_map_method')) {
    /**
     * メソッドを指定できるようにした array_map
     *
     * 配列内の要素は全て同一（少なくともシグネチャが同じ $method が存在する）オブジェクトでなければならない。
     * スルーする場合は $ignore=true とする。スルーした場合 map ではなく filter される（結果配列に含まれない）。
     * $ignore=null とすると 何もせずそのまま要素を返す。
     *
     * Example:
     * ```php
     * $exa = new \Exception('a');
     * $exb = new \Exception('b');
     * $std = new \stdClass();
     * // getMessage で map される
     * that(array_map_method([$exa, $exb], 'getMessage'))->isSame(['a', 'b']);
     * // getMessage で map されるが、メソッドが存在しない場合は取り除かれる
     * that(array_map_method([$exa, $exb, $std, null], 'getMessage', [], true))->isSame(['a', 'b']);
     * // getMessage で map されるが、メソッドが存在しない場合はそのまま返す
     * that(array_map_method([$exa, $exb, $std, null], 'getMessage', [], null))->isSame(['a', 'b', $std, null]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string $method メソッド
     * @param array $args メソッドに渡る引数
     * @param bool|null $ignore メソッドが存在しない場合にスルーするか。null を渡すと要素そのものを返す
     * @return array $method が true を返した新しい配列
     */
    function array_map_method($array, $method, $args = [], $ignore = false)
    {
        if ($ignore === true) {
            $array = array_filter(arrayval($array, false), fn($object) => is_callable([$object, $method]));
        }
        return array_map(function ($object) use ($method, $args, $ignore) {
            if ($ignore === null && !is_callable([$object, $method])) {
                return $object;
            }
            return ([$object, $method])(...$args);
        }, arrayval($array, false));
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_sprintf') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_sprintf'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_sprintf')) {
    /**
     * キーと値で sprintf する
     *
     * 配列の各要素を文字列化して返すイメージ。
     * $glue を与えるとさらに implode して返す（返り値が文字列になる）。
     *
     * $format は書式文字列（$v, $k）。
     * callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。
     * 省略（null）するとキーを format 文字列、値を引数として **vsprintf** する。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // key, value を利用した sprintf
     * that(array_sprintf($array, '%2$s=%1$s'))->isSame(['key1=val1', 'key2=val2']);
     * // 第3引数を与えるとさらに implode される
     * that(array_sprintf($array, '%2$s=%1$s', ' '))->isSame('key1=val1 key2=val2');
     * // クロージャを与えるとコールバック動作になる
     * $closure = fn($v, $k) => "$k=" . strtoupper($v);
     * that(array_sprintf($array, $closure, ' '))->isSame('key1=VAL1 key2=VAL2');
     * // 省略すると vsprintf になる
     * that(array_sprintf([
     *     'str:%s,int:%d' => ['sss', '3.14'],
     *     'single:%s'     => 'str',
     * ], null, '|'))->isSame('str:sss,int:3|single:str');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|callable|null $format 書式文字列あるいはクロージャ
     * @param ?string $glue 結合文字列。未指定時は implode しない
     * @return array|string sprintf された配列
     */
    function array_sprintf($array, $format = null, $glue = null)
    {
        if (is_callable($format)) {
            $callback = func_user_func_array($format);
        }
        elseif ($format === null) {
            $callback = fn($v, $k, $n) => vsprintf($k, is_array($v) ? $v : [$v]);
        }
        else {
            $callback = fn($v, $k, $n) => sprintf($format, $v, $k);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $result[] = $callback($v, $k, $n++);
        }

        if ($glue !== null) {
            return implode($glue, $result);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\array_unset') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\array_unset'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\array_unset')) {
    /**
     * 伏せると同時にその値を返す
     *
     * $key に配列を与えると全て伏せて配列で返す。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 配列を与えた場合の返り値は与えた配列の順番・キーが活きる。
     * これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。
     * callable ではなくクロージャのみ対応する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B'];
     * // ない場合は $default を返す
     * that(array_unset($array, 'x', 'X'))->isSame('X');
     * // 指定したキーを返す。そのキーは伏せられている
     * that(array_unset($array, 'a'))->isSame('A');
     * that($array)->isSame(['b' => 'B']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列を与えるとそれらを返す。そのキーは全て伏せられている
     * that(array_unset($array, ['a', 'b', 'x']))->isSame(['A', 'B']);
     * that($array)->isSame(['c' => 'C']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列のキーは返されるキーを表す。順番も維持される
     * that(array_unset($array, ['x2' => 'b', 'x1' => 'a']))->isSame(['x2' => 'B', 'x1' => 'A']);
     *
     * $array = ['hoge' => 'HOGE', 'fuga' => 'FUGA', 'piyo' => 'PIYO'];
     * // 値に "G" を含むものを返す。その要素は伏せられている
     * that(array_unset($array, fn($v) => strpos($v, 'G') !== false))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * that($array)->isSame(['piyo' => 'PIYO']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 配列
     * @param string|int|array|callable $key 伏せたいキー。配列を与えると全て伏せる。クロージャの場合は true 相当を伏せる
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_unset(&$array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $rk => $ak) {
                if (array_keys_exist($ak, $array)) {
                    $result[$rk] = $array[$ak];
                    unset($array[$ak]);
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    $result[$k] = $v;
                    unset($array[$k]);
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            $result = $array[$key];
            unset($array[$key]);
            return $result;
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\arrayize') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\arrayize'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\arrayize')) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 連想配列は未対応。あくまで普通の配列化のみ。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif (!is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                $result += $arg;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\is_hasharray') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\is_hasharray'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\is_hasharray')) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\last_key') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\last_key'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\last_key')) {
    /**
     * 配列の最後のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_key(['a', 'b', 'c']))->isSame(2);
     * that(last_key([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後のキー
     */
    function last_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $k;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\last_keyvalue') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\last_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\last_keyvalue')) {
    /**
     * 配列の最後のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_keyvalue(['a', 'b', 'c']))->isSame([2, 'c']);
     * that(last_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最後のキー, 最後の値]
     */
    function last_keyvalue($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        if (is_array($array)) {
            $k = array_key_last($array);
            return [$k, $array[$k]];
        }
        /** @noinspection PhpStatementHasEmptyBodyInspection */
        foreach ($array as $k => $v) {
            // dummy
        }
        // $k がセットされてるなら「ループが最低でも1度回った（≠空）」とみなせる
        if (isset($k)) {
            /** @noinspection PhpUndefinedVariableInspection */
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\auto_loader') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\auto_loader'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\auto_loader')) {
    /**
     * vendor/autoload.php を返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(auto_loader())->contains('autoload.php');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return string autoload.php のフルパス
     */
    function auto_loader($startdir = null)
    {
        return cache("path-$startdir", function () use ($startdir) {
            $cache = dirname_r($startdir ?: __DIR__, function ($dir) {
                if (file_exists($file = "$dir/autoload.php") || file_exists($file = "$dir/vendor/autoload.php")) {
                    return $file;
                }
            });
            if (!$cache) {
                throw new \DomainException('autoloader is not found.');
            }
            return $cache;
        }, __FUNCTION__);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\class_loader') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\class_loader'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\class_loader')) {
    /**
     * composer のクラスローダを返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(class_loader())->isInstanceOf(\Composer\Autoload\ClassLoader::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return \Composer\Autoload\ClassLoader クラスローダ
     */
    function class_loader($startdir = null)
    {
        return require auto_loader($startdir);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\class_replace') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\class_replace'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\class_replace')) {
    /**
     * 既存（未読み込みに限る）クラスを強制的に置換する
     *
     * 例えば継承ツリーが下記の場合を考える。
     *
     * classA <- classB <- classC
     *
     * この場合、「classC は classB に」「classB は classA に」それぞれ依存している、と考えることができる。
     * これは静的に決定的であり、この依存を壊したり注入したりする手段は存在しない。
     * 例えば classA の実装を差し替えたいときに、いかに classA を継承した classAA を定義したとしても classB の親は classA で決して変わらない。
     *
     * この関数を使うと本当に classA そのものを弄るので、継承ツリーを下記のように変えることができる。
     *
     * classA <- classAA <- classB <- classC
     *
     * つまり、classA を継承した classAA を定義してそれを classA とみなすことが可能になる。
     * ただし、内部的には class_alias を使用して実現しているので厳密には異なるクラスとなる。
     *
     * 実際のところかなり強力な機能だが、同時にかなり黒魔術的なので乱用は控えたほうがいい。
     *
     * Example:
     * ```php
     * // Y1 extends X1 だとしてクラス定義でオーバーライドする
     * class_replace('\\ryunosuke\\Test\\Package\\files\\classes\\X1', function () {
     *     // アンスコがついたクラスが定義されるのでそれを継承して定義する
     *     class X1d extends \ryunosuke\Test\Package\files\classes\X1_
     *     {
     *         function method(){return 'this is X1d';}
     *         function newmethod(){return 'this is newmethod';}
     *     }
     *     // このように匿名クラスを返しても良い。ただし、混在せずにどちらか一方にすること
     *     return new class() extends \ryunosuke\Test\Package\files\classes\X1_
     *     {
     *         function method(){return 'this is X1d';}
     *         function newmethod(){return 'this is newmethod';}
     *     };
     * });
     * // X1 を継承している Y1 にまで影響が出ている（X1 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y1())->method())->isSame('this is X1d');
     * that((new \ryunosuke\Test\Package\files\classes\Y1())->newmethod())->isSame('this is newmethod');
     *
     * // Y2 extends X2 だとしてクロージャ配列でオーバーライドする
     * class_replace('\\ryunosuke\\Test\\Package\\files\classes\\X2', fn() => [
     *     'method'    => function () {return 'this is X2d';},
     *     'newmethod' => function () {return 'this is newmethod';},
     * ]);
     * // X2 を継承している Y2 にまで影響が出ている（X2 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y2())->method())->isSame('this is X2d');
     * that((new \ryunosuke\Test\Package\files\classes\Y2())->newmethod())->isSame('this is newmethod');
     *
     * // メソッド定義だけであればクロージャではなく配列指定でも可能。さらに trait 配列を渡すとそれらを use できる
     * class_replace('\\ryunosuke\\Test\\Package\\files\classes\\X3', [
     *     [\ryunosuke\Test\Package\files\classes\XTrait::class],
     *     'method' => function () {return 'this is X3d';},
     * ]);
     * // X3 を継承している Y3 にまで影響が出ている（X3 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y3())->method())->isSame('this is X3d');
     * // トレイトのメソッドも生えている
     * that((new \ryunosuke\Test\Package\files\classes\Y3())->traitMethod())->isSame('this is XTrait::traitMethod');
     *
     * // メソッドとトレイトだけならば無名クラスを渡すことでも可能
     * class_replace('\\ryunosuke\\Test\\Package\\files\classes\\X4', new class() {
     *     use \ryunosuke\Test\Package\files\classes\XTrait;
     *     function method(){return 'this is X4d';}
     * });
     * // X4 を継承している Y4 にまで影響が出ている（X4 を完全に置換できたということ）
     * that((new \ryunosuke\Test\Package\files\classes\Y4())->method())->isSame('this is X4d');
     * // トレイトのメソッドも生えている
     * that((new \ryunosuke\Test\Package\files\classes\Y4())->traitMethod())->isSame('this is XTrait::traitMethod');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $class 対象クラス名
     * @param \Closure|object|array $register 置換クラスを定義 or 返すクロージャ or 定義メソッド配列 or 無名クラス
     */
    function class_replace($class, $register)
    {
        $class = ltrim($class, '\\');

        // 読み込み済みクラスは置換できない（php はクラスのアンロード機能が存在しない）
        if (class_exists($class, false)) {
            throw new \DomainException("'$class' is already declared.");
        }

        // 対象クラス名をちょっとだけ変えたクラスを用意して読み込む
        $classfile = class_loader()->findFile($class);
        $fname = function_configure('cachedir') . '/' . rawurlencode(__FUNCTION__ . '-' . $class) . '.php';
        if (!file_exists($fname)) {
            $content = file_get_contents($classfile);
            $content = preg_replace("#class\\s+[a-z0-9_]+#ui", '$0_', $content);
            file_put_contents($fname, $content, LOCK_EX);
        }
        require_once $fname;

        $classess = get_declared_classes();
        if ($register instanceof \Closure) {
            $newclass = $register();
        }
        elseif (is_object($register)) {
            $ref = new \ReflectionObject($register);
            $newclass = [class_uses($register)];
            $trait_methods = $ref->getTraitAliases();
            foreach (class_uses($register) as $trait) {
                $trait_methods += array_flip(get_class_methods($trait));
            }
            foreach ($ref->getMethods() as $method) {
                if (!isset($trait_methods[$method->getName()])) {
                    $newclass[$method->getName()] = $method->isStatic() ? $method->getClosure() : $method->getClosure($register);
                }
            }
        }
        else {
            $newclass = $register;
        }

        // クロージャ内部でクラス定義した場合（増えたクラスでエイリアスする）
        if ($newclass === null) {
            $classes = array_diff(get_declared_classes(), $classess);
            if (count($classes) !== 1) {
                throw new \DomainException('declared multi classes.' . implode(',', $classes));
            }
            $newclass = reset($classes);
        }
        // php7.0 から無名クラスが使えるのでそのクラス名でエイリアスする
        if (is_object($newclass)) {
            $newclass = get_class($newclass);
        }
        // 配列はメソッド定義のクロージャ配列とする
        if (is_array($newclass)) {
            $content = file_get_contents($fname);
            $origspace = parse_php($content, [
                'begin' => T_NAMESPACE,
                'end'   => ';',
            ]);
            array_shift($origspace);
            array_pop($origspace);

            $origclass = parse_php($content, [
                'begin'  => T_CLASS,
                'end'    => T_STRING,
                'offset' => count($origspace),
            ]);
            array_shift($origclass);

            $origspace = trim(implode('', array_column($origspace, 1)));
            $origclass = trim(implode('', array_column($origclass, 1)));

            $classcode = '';
            foreach ($newclass as $name => $member) {
                if (is_array($member)) {
                    foreach ($member as $trait) {
                        $classcode .= "use \\" . trim($trait, '\\') . ";\n";
                    }
                }
                else {
                    [$declare, $codeblock] = callable_code($member);
                    $parentclass = new \ReflectionClass("\\$origspace\\$origclass");
                    // 元クラスに定義されているならオーバーライドとして特殊な処理を行う
                    if ($parentclass->hasMethod($name)) {
                        /** @var \ReflectionFunctionAbstract $refmember */
                        $refmember = reflect_callable($member);
                        $refmethod = $parentclass->getMethod($name);
                        // 指定クロージャに引数が無くて、元メソッドに有るなら継承
                        if (!$refmember->getNumberOfParameters() && $refmethod->getNumberOfParameters()) {
                            $declare = 'function (' . implode(', ', function_parameter($refmethod)) . ')';
                        }
                        // 同上。返り値版
                        if (!$refmember->hasReturnType() && $refmethod->hasReturnType()) {
                            $declare .= ':' . reflect_types($refmethod->getReturnType())->getName();
                        }
                    }
                    $mname = preg_replaces('#function(\\s*)\\(#u', " $name", $declare);
                    $classcode .= "public $mname $codeblock\n";
                }
            }

            $newclass = "\\$origspace\\{$origclass}_";
            evaluate("namespace $origspace;\nclass {$origclass}_ extends {$origclass}\n{\n$classcode}");
        }

        class_alias($newclass, $class);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\class_shorten') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\class_shorten'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\class_shorten')) {
    /**
     * クラスの名前空間部分を除いた短い名前を取得する
     *
     * Example:
     * ```php
     * that(class_shorten('vendor\\namespace\\ClassName'))->isSame('ClassName');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $class 対象クラス・オブジェクト
     * @return string クラスの短い名前
     */
    function class_shorten($class)
    {
        if (is_object($class)) {
            $class = get_class($class);
        }

        $parts = explode('\\', $class);
        return array_pop($parts);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\get_object_properties') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\get_object_properties'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\get_object_properties')) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     * クロージャだけは特別扱いで this + use 変数を返す。
     *
     * Example:
     * ```php
     * $object = new \Exception('something', 42);
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(get_object_properties($object))->subsetEquals([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     *
     * // クロージャは this と use 変数を返す
     * that(get_object_properties(fn() => $object))->is([
     *     'this'   => $this,
     *     'object' => $object,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function get_object_properties($object, &$privates = [])
    {
        if ($object instanceof \Closure) {
            $ref = new \ReflectionFunction($object);
            $uses = method_exists($ref, 'getClosureUsedVariables') ? $ref->getClosureUsedVariables() : $ref->getStaticVariables();
            return ['this' => $ref->getClosureThis()] + $uses;
        }

        $fields = [];
        foreach ((array) $object as $name => $field) {
            $cname = '';
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
            }
            $fields[$cname][$name] = $field;
        }

        $classname = get_class($object);
        $parents = array_values(['', '*', $classname] + class_parents($object));
        uksort($fields, function ($a, $b) use ($parents) {
            return array_search($a, $parents, true) <=> array_search($b, $parents, true);
        });

        $result = [];
        foreach ($fields as $cname => $props) {
            foreach ($props as $name => $field) {
                if ($cname !== '' && $cname !== '*' && $classname !== $cname) {
                    $privates[$cname][$name] = $field;
                }
                if (!array_key_exists($name, $result)) {
                    $result[$name] = $field;
                }
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\sql_bind') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\sql_bind'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\sql_bind')) {
    /**
     * ものすごく雑に SQL に値を埋め込む
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * プレースホルダは ? か :alnum で混在していても良い。
     *
     * Example:
     * ```php
     * that(sql_bind('select ?', 1))->isSame("select 1");
     * that(sql_bind('select :hoge', ['hoge' => 'hoge']))->isSame("select 'hoge'");
     * that(sql_bind('select ?, :hoge', [1, 'hoge' => 'hoge']))->isSame("select 1, 'hoge'");
     * ```
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param string $sql 値を埋め込む SQL
     * @param array|mixed $values 埋め込む値
     * @param ?callable $quote 値をクォートするクロージャ
     * @return mixed 値が埋め込まれた SQL
     */
    function sql_bind($sql, $values, $quote = null)
    {
        $quote ??= fn($v) => sql_quote($v);

        $embed = [];
        foreach (arrayval($values, false) as $k => $v) {
            if (is_int($k)) {
                $embed['?'][] = $quote($v);
            }
            else {
                $embed[":$k"] = $quote($v);
            }
        }

        return str_embed($sql, $embed, [
            "'"   => "'",
            '"'   => '"',
            '-- ' => "\n",
            '/*'  => "*/",
        ]);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\sql_format') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\sql_format'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\sql_format')) {
    /**
     * ものすごく雑に SQL を整形する
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * JOIN 句は FROM 句とみなさず、別句として処理する。
     * AND と && は微妙に処理が異なる。 AND は改行されるが && は改行されない（OR と || も同様）。
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param string $sql 整形する SQL
     * @param array $options 整形オプション
     * @return string 整形された SQL
     */
    function sql_format($sql, $options = [])
    {
        static $keywords = [
            'ACCESSIBLE'                 => true,
            'ACTION'                     => true,
            'ADD'                        => true,
            'AFTER'                      => true,
            'AGAINST'                    => true,
            'AGGREGATE'                  => true,
            'ALGORITHM'                  => true,
            'ALL'                        => true,
            'ALTER'                      => true,
            'ALTER TABLE'                => true,
            'ANALYSE'                    => true,
            'ANALYZE'                    => true,
            'AND'                        => true,
            'AS'                         => true,
            'ASC'                        => true,
            'AUTOCOMMIT'                 => true,
            'AUTO_INCREMENT'             => true,
            'BACKUP'                     => true,
            'BEGIN'                      => true,
            'BETWEEN'                    => true,
            'BINLOG'                     => true,
            'BOTH'                       => true,
            'CASCADE'                    => true,
            'CASE'                       => true,
            'CHANGE'                     => true,
            'CHANGED'                    => true,
            'CHARACTER SET'              => true,
            'CHARSET'                    => true,
            'CHECK'                      => true,
            'CHECKSUM'                   => true,
            'COLLATE'                    => true,
            'COLLATION'                  => true,
            'COLUMN'                     => true,
            'COLUMNS'                    => true,
            'COMMENT'                    => true,
            'COMMIT'                     => true,
            'COMMITTED'                  => true,
            'COMPRESSED'                 => true,
            'CONCURRENT'                 => true,
            'CONSTRAINT'                 => true,
            'CONTAINS'                   => true,
            'CONVERT'                    => true,
            'CREATE'                     => true,
            'CROSS'                      => true,
            'CURRENT_TIMESTAMP'          => true,
            'DATABASE'                   => true,
            'DATABASES'                  => true,
            'DAY'                        => true,
            'DAY_HOUR'                   => true,
            'DAY_MINUTE'                 => true,
            'DAY_SECOND'                 => true,
            'DEFAULT'                    => true,
            'DEFINER'                    => true,
            'DELAYED'                    => true,
            'DELETE'                     => true,
            'DELETE FROM'                => true,
            'DESC'                       => true,
            'DESCRIBE'                   => true,
            'DETERMINISTIC'              => true,
            'DISTINCT'                   => true,
            'DISTINCTROW'                => true,
            'DIV'                        => true,
            'DO'                         => true,
            'DROP'                       => true,
            'DUMPFILE'                   => true,
            'DUPLICATE'                  => true,
            'DYNAMIC'                    => true,
            'ELSE'                       => true,
            'ENCLOSED'                   => true,
            'END'                        => true,
            'ENGINE'                     => true,
            'ENGINES'                    => true,
            'ENGINE_TYPE'                => true,
            'ESCAPE'                     => true,
            'ESCAPED'                    => true,
            'EVENTS'                     => true,
            'EXCEPT'                     => true,
            'EXECUTE'                    => true,
            'EXISTS'                     => true,
            'EXPLAIN'                    => true,
            'EXTENDED'                   => true,
            'FAST'                       => true,
            'FIELDS'                     => true,
            'FILE'                       => true,
            'FIRST'                      => true,
            'FIXED'                      => true,
            'FLUSH'                      => true,
            'FOR'                        => true,
            'FORCE'                      => true,
            'FOREIGN'                    => true,
            'FROM'                       => true,
            'FULL'                       => true,
            'FULLTEXT'                   => true,
            'FUNCTION'                   => true,
            'GLOBAL'                     => true,
            'GRANT'                      => true,
            'GRANTS'                     => true,
            'GROUP'                      => true,
            'GROUP_CONCAT'               => true,
            'HAVING'                     => true,
            'HEAP'                       => true,
            'HIGH_PRIORITY'              => true,
            'HOSTS'                      => true,
            'HOUR'                       => true,
            'HOUR_MINUTE'                => true,
            'HOUR_SECOND'                => true,
            'IDENTIFIED'                 => true,
            'IF'                         => true,
            'IFNULL'                     => true,
            'IGNORE'                     => true,
            'IN'                         => true,
            'INDEX'                      => true,
            'INDEXES'                    => true,
            'INFILE'                     => true,
            'INNER'                      => true,
            'INSERT'                     => true,
            'INSERT_ID'                  => true,
            'INSERT_METHOD'              => true,
            'INTERSECT'                  => true,
            'INTERVAL'                   => true,
            'INTO'                       => true,
            'INVOKER'                    => true,
            'IS'                         => true,
            'ISOLATION'                  => true,
            'JOIN'                       => true,
            'JSON_ARRAY'                 => true,
            'JSON_ARRAY_APPEND'          => true,
            'JSON_ARRAY_INSERT'          => true,
            'JSON_CONTAINS'              => true,
            'JSON_CONTAINS_PATH'         => true,
            'JSON_DEPTH'                 => true,
            'JSON_EXTRACT'               => true,
            'JSON_INSERT'                => true,
            'JSON_KEYS'                  => true,
            'JSON_LENGTH'                => true,
            'JSON_MERGE_PATCH'           => true,
            'JSON_MERGE_PRESERVE'        => true,
            'JSON_OBJECT'                => true,
            'JSON_PRETTY'                => true,
            'JSON_QUOTE'                 => true,
            'JSON_REMOVE'                => true,
            'JSON_REPLACE'               => true,
            'JSON_SEARCH'                => true,
            'JSON_SET'                   => true,
            'JSON_STORAGE_SIZE'          => true,
            'JSON_TYPE'                  => true,
            'JSON_UNQUOTE'               => true,
            'JSON_VALID'                 => true,
            'KEY'                        => true,
            'KEYS'                       => true,
            'KILL'                       => true,
            'LAST_INSERT_ID'             => true,
            'LEADING'                    => true,
            'LEFT'                       => true,
            'LEVEL'                      => true,
            'LIKE'                       => true,
            'LIMIT'                      => true,
            'LINEAR'                     => true,
            'LINES'                      => true,
            'LOAD'                       => true,
            'LOCAL'                      => true,
            'LOCK'                       => true,
            'LOCKS'                      => true,
            'LOGS'                       => true,
            'LOW_PRIORITY'               => true,
            'MARIA'                      => true,
            'MASTER'                     => true,
            'MASTER_CONNECT_RETRY'       => true,
            'MASTER_HOST'                => true,
            'MASTER_LOG_FILE'            => true,
            'MATCH'                      => true,
            'MAX_CONNECTIONS_PER_HOUR'   => true,
            'MAX_QUERIES_PER_HOUR'       => true,
            'MAX_ROWS'                   => true,
            'MAX_UPDATES_PER_HOUR'       => true,
            'MAX_USER_CONNECTIONS'       => true,
            'MEDIUM'                     => true,
            'MERGE'                      => true,
            'MINUTE'                     => true,
            'MINUTE_SECOND'              => true,
            'MIN_ROWS'                   => true,
            'MODE'                       => true,
            'MODIFY'                     => true,
            'MONTH'                      => true,
            'MRG_MYISAM'                 => true,
            'MYISAM'                     => true,
            'NAMES'                      => true,
            'NATURAL'                    => true,
            'NOT'                        => true,
            'NOW()'                      => true,
            'NULL'                       => true,
            'OFFSET'                     => true,
            'ON'                         => true,
            'ON DELETE'                  => true,
            'ON UPDATE'                  => true,
            'OPEN'                       => true,
            'OPTIMIZE'                   => true,
            'OPTION'                     => true,
            'OPTIONALLY'                 => true,
            'OR'                         => true,
            'ORDER'                      => true,
            'BY'                         => true,
            'OUTER'                      => true,
            'OUTFILE'                    => true,
            'PACK_KEYS'                  => true,
            'PAGE'                       => true,
            'PARTIAL'                    => true,
            'PARTITION'                  => true,
            'PARTITIONS'                 => true,
            'PASSWORD'                   => true,
            'PRIMARY'                    => true,
            'PRIVILEGES'                 => true,
            'PROCEDURE'                  => true,
            'PROCESS'                    => true,
            'PROCESSLIST'                => true,
            'PURGE'                      => true,
            'QUICK'                      => true,
            'RAID0'                      => true,
            'RAID_CHUNKS'                => true,
            'RAID_CHUNKSIZE'             => true,
            'RAID_TYPE'                  => true,
            'RANGE'                      => true,
            'READ'                       => true,
            'READ_ONLY'                  => true,
            'READ_WRITE'                 => true,
            'REFERENCES'                 => true,
            'REGEXP'                     => true,
            'RELOAD'                     => true,
            'RENAME'                     => true,
            'REPAIR'                     => true,
            'REPEATABLE'                 => true,
            'REPLACE'                    => true,
            'REPLICATION'                => true,
            'RESET'                      => true,
            'RESTORE'                    => true,
            'RESTRICT'                   => true,
            'RETURN'                     => true,
            'RETURNS'                    => true,
            'REVOKE'                     => true,
            'RIGHT'                      => true,
            'RLIKE'                      => true,
            'ROLLBACK'                   => true,
            'ROLLUP'                     => true,
            'ROW'                        => true,
            'ROWS'                       => true,
            'ROW_FORMAT'                 => true,
            'SECOND'                     => true,
            'SECURITY'                   => true,
            'SELECT'                     => true,
            'SEPARATOR'                  => true,
            'SERIALIZABLE'               => true,
            'SESSION'                    => true,
            'SET'                        => true,
            'SHARE'                      => true,
            'SHOW'                       => true,
            'SHUTDOWN'                   => true,
            'SLAVE'                      => true,
            'SONAME'                     => true,
            'SOUNDS'                     => true,
            'SQL'                        => true,
            'SQL_AUTO_IS_NULL'           => true,
            'SQL_BIG_RESULT'             => true,
            'SQL_BIG_SELECTS'            => true,
            'SQL_BIG_TABLES'             => true,
            'SQL_BUFFER_RESULT'          => true,
            'SQL_CACHE'                  => true,
            'SQL_CALC_FOUND_ROWS'        => true,
            'SQL_LOG_BIN'                => true,
            'SQL_LOG_OFF'                => true,
            'SQL_LOG_UPDATE'             => true,
            'SQL_LOW_PRIORITY_UPDATES'   => true,
            'SQL_MAX_JOIN_SIZE'          => true,
            'SQL_NO_CACHE'               => true,
            'SQL_QUOTE_SHOW_CREATE'      => true,
            'SQL_SAFE_UPDATES'           => true,
            'SQL_SELECT_LIMIT'           => true,
            'SQL_SLAVE_SKIP_COUNTER'     => true,
            'SQL_SMALL_RESULT'           => true,
            'SQL_WARNINGS'               => true,
            'START'                      => true,
            'STARTING'                   => true,
            'STATUS'                     => true,
            'STOP'                       => true,
            'STORAGE'                    => true,
            'STRAIGHT_JOIN'              => true,
            'STRING'                     => true,
            'STRIPED'                    => true,
            'SUPER'                      => true,
            'TABLE'                      => true,
            'TABLES'                     => true,
            'TEMPORARY'                  => true,
            'TERMINATED'                 => true,
            'THEN'                       => true,
            'TO'                         => true,
            'TRAILING'                   => true,
            'TRANSACTIONAL'              => true,
            'TRUE'                       => true,
            'TRUNCATE'                   => true,
            'TYPE'                       => true,
            'TYPES'                      => true,
            'UNCOMMITTED'                => true,
            'UNION'                      => true,
            'UNION ALL'                  => true,
            'UNIQUE'                     => true,
            'UNLOCK'                     => true,
            'UNSIGNED'                   => true,
            'UPDATE'                     => true,
            'USAGE'                      => true,
            'USE'                        => true,
            'USING'                      => true,
            'VALUES'                     => true,
            'VARIABLES'                  => true,
            'VIEW'                       => true,
            'WHEN'                       => true,
            'WHERE'                      => true,
            'WITH'                       => true,
            'WORK'                       => true,
            'WRITE'                      => true,
            'XOR'                        => true,
            'YEAR_MONTH'                 => true,
            'ABS'                        => true,
            'ACOS'                       => true,
            'ADDDATE'                    => true,
            'ADDTIME'                    => true,
            'AES_DECRYPT'                => true,
            'AES_ENCRYPT'                => true,
            'AREA'                       => true,
            'ASBINARY'                   => true,
            'ASCII'                      => true,
            'ASIN'                       => true,
            'ASTEXT'                     => true,
            'ATAN'                       => true,
            'ATAN2'                      => true,
            'AVG'                        => true,
            'BDMPOLYFROMTEXT'            => true,
            'BDMPOLYFROMWKB'             => true,
            'BDPOLYFROMTEXT'             => true,
            'BDPOLYFROMWKB'              => true,
            'BENCHMARK'                  => true,
            'BIN'                        => true,
            'BIT_AND'                    => true,
            'BIT_COUNT'                  => true,
            'BIT_LENGTH'                 => true,
            'BIT_OR'                     => true,
            'BIT_XOR'                    => true,
            'BOUNDARY'                   => true,
            'BUFFER'                     => true,
            'CAST'                       => true,
            'CEIL'                       => true,
            'CEILING'                    => true,
            'CENTROID'                   => true,
            'CHAR'                       => true,
            'CHARACTER_LENGTH'           => true,
            'CHAR_LENGTH'                => true,
            'COALESCE'                   => true,
            'COERCIBILITY'               => true,
            'COMPRESS'                   => true,
            'CONCAT'                     => true,
            'CONCAT_WS'                  => true,
            'CONNECTION_ID'              => true,
            'CONV'                       => true,
            'CONVERT_TZ'                 => true,
            'CONVEXHULL'                 => true,
            'COS'                        => true,
            'COT'                        => true,
            'COUNT'                      => true,
            'CRC32'                      => true,
            'CROSSES'                    => true,
            'CURDATE'                    => true,
            'CURRENT_DATE'               => true,
            'CURRENT_TIME'               => true,
            'CURRENT_USER'               => true,
            'CURTIME'                    => true,
            'DATE'                       => true,
            'DATEDIFF'                   => true,
            'DATE_ADD'                   => true,
            'DATE_DIFF'                  => true,
            'DATE_FORMAT'                => true,
            'DATE_SUB'                   => true,
            'DAYNAME'                    => true,
            'DAYOFMONTH'                 => true,
            'DAYOFWEEK'                  => true,
            'DAYOFYEAR'                  => true,
            'DECODE'                     => true,
            'DEGREES'                    => true,
            'DES_DECRYPT'                => true,
            'DES_ENCRYPT'                => true,
            'DIFFERENCE'                 => true,
            'DIMENSION'                  => true,
            'DISJOINT'                   => true,
            'DISTANCE'                   => true,
            'ELT'                        => true,
            'ENCODE'                     => true,
            'ENCRYPT'                    => true,
            'ENDPOINT'                   => true,
            'ENVELOPE'                   => true,
            'EQUALS'                     => true,
            'EXP'                        => true,
            'EXPORT_SET'                 => true,
            'EXTERIORRING'               => true,
            'EXTRACT'                    => true,
            'EXTRACTVALUE'               => true,
            'FIELD'                      => true,
            'FIND_IN_SET'                => true,
            'FLOOR'                      => true,
            'FORMAT'                     => true,
            'FOUND_ROWS'                 => true,
            'FROM_DAYS'                  => true,
            'FROM_UNIXTIME'              => true,
            'GEOMCOLLFROMTEXT'           => true,
            'GEOMCOLLFROMWKB'            => true,
            'GEOMETRYCOLLECTION'         => true,
            'GEOMETRYCOLLECTIONFROMTEXT' => true,
            'GEOMETRYCOLLECTIONFROMWKB'  => true,
            'GEOMETRYFROMTEXT'           => true,
            'GEOMETRYFROMWKB'            => true,
            'GEOMETRYN'                  => true,
            'GEOMETRYTYPE'               => true,
            'GEOMFROMTEXT'               => true,
            'GEOMFROMWKB'                => true,
            'GET_FORMAT'                 => true,
            'GET_LOCK'                   => true,
            'GLENGTH'                    => true,
            'GREATEST'                   => true,
            'GROUP_UNIQUE_USERS'         => true,
            'HEX'                        => true,
            'INET_ATON'                  => true,
            'INET_NTOA'                  => true,
            'INSTR'                      => true,
            'INTERIORRINGN'              => true,
            'INTERSECTION'               => true,
            'INTERSECTS'                 => true,
            'ISCLOSED'                   => true,
            'ISEMPTY'                    => true,
            'ISNULL'                     => true,
            'ISRING'                     => true,
            'ISSIMPLE'                   => true,
            'IS_FREE_LOCK'               => true,
            'IS_USED_LOCK'               => true,
            'LAST_DAY'                   => true,
            'LCASE'                      => true,
            'LEAST'                      => true,
            'LENGTH'                     => true,
            'LINEFROMTEXT'               => true,
            'LINEFROMWKB'                => true,
            'LINESTRING'                 => true,
            'LINESTRINGFROMTEXT'         => true,
            'LINESTRINGFROMWKB'          => true,
            'LN'                         => true,
            'LOAD_FILE'                  => true,
            'LOCALTIME'                  => true,
            'LOCALTIMESTAMP'             => true,
            'LOCATE'                     => true,
            'LOG'                        => true,
            'LOG10'                      => true,
            'LOG2'                       => true,
            'LOWER'                      => true,
            'LPAD'                       => true,
            'LTRIM'                      => true,
            'MAKEDATE'                   => true,
            'MAKETIME'                   => true,
            'MAKE_SET'                   => true,
            'MASTER_POS_WAIT'            => true,
            'MAX'                        => true,
            'MBRCONTAINS'                => true,
            'MBRDISJOINT'                => true,
            'MBREQUAL'                   => true,
            'MBRINTERSECTS'              => true,
            'MBROVERLAPS'                => true,
            'MBRTOUCHES'                 => true,
            'MBRWITHIN'                  => true,
            'MD5'                        => true,
            'MICROSECOND'                => true,
            'MID'                        => true,
            'MIN'                        => true,
            'MLINEFROMTEXT'              => true,
            'MLINEFROMWKB'               => true,
            'MOD'                        => true,
            'MONTHNAME'                  => true,
            'MPOINTFROMTEXT'             => true,
            'MPOINTFROMWKB'              => true,
            'MPOLYFROMTEXT'              => true,
            'MPOLYFROMWKB'               => true,
            'MULTILINESTRING'            => true,
            'MULTILINESTRINGFROMTEXT'    => true,
            'MULTILINESTRINGFROMWKB'     => true,
            'MULTIPOINT'                 => true,
            'MULTIPOINTFROMTEXT'         => true,
            'MULTIPOINTFROMWKB'          => true,
            'MULTIPOLYGON'               => true,
            'MULTIPOLYGONFROMTEXT'       => true,
            'MULTIPOLYGONFROMWKB'        => true,
            'NAME_CONST'                 => true,
            'NULLIF'                     => true,
            'NUMGEOMETRIES'              => true,
            'NUMINTERIORRINGS'           => true,
            'NUMPOINTS'                  => true,
            'OCT'                        => true,
            'OCTET_LENGTH'               => true,
            'OLD_PASSWORD'               => true,
            'ORD'                        => true,
            'OVERLAPS'                   => true,
            'PERIOD_ADD'                 => true,
            'PERIOD_DIFF'                => true,
            'PI'                         => true,
            'POINT'                      => true,
            'POINTFROMTEXT'              => true,
            'POINTFROMWKB'               => true,
            'POINTN'                     => true,
            'POINTONSURFACE'             => true,
            'POLYFROMTEXT'               => true,
            'POLYFROMWKB'                => true,
            'POLYGON'                    => true,
            'POLYGONFROMTEXT'            => true,
            'POLYGONFROMWKB'             => true,
            'POSITION'                   => true,
            'POW'                        => true,
            'POWER'                      => true,
            'QUARTER'                    => true,
            'QUOTE'                      => true,
            'RADIANS'                    => true,
            'RAND'                       => true,
            'RELATED'                    => true,
            'RELEASE_LOCK'               => true,
            'REPEAT'                     => true,
            'REVERSE'                    => true,
            'ROUND'                      => true,
            'ROW_COUNT'                  => true,
            'RPAD'                       => true,
            'RTRIM'                      => true,
            'SCHEMA'                     => true,
            'SEC_TO_TIME'                => true,
            'SESSION_USER'               => true,
            'SHA'                        => true,
            'SHA1'                       => true,
            'SIGN'                       => true,
            'SIN'                        => true,
            'SLEEP'                      => true,
            'SOUNDEX'                    => true,
            'SPACE'                      => true,
            'SQRT'                       => true,
            'SRID'                       => true,
            'STARTPOINT'                 => true,
            'STD'                        => true,
            'STDDEV'                     => true,
            'STDDEV_POP'                 => true,
            'STDDEV_SAMP'                => true,
            'STRCMP'                     => true,
            'STR_TO_DATE'                => true,
            'SUBDATE'                    => true,
            'SUBSTR'                     => true,
            'SUBSTRING'                  => true,
            'SUBSTRING_INDEX'            => true,
            'SUBTIME'                    => true,
            'SUM'                        => true,
            'SYMDIFFERENCE'              => true,
            'SYSDATE'                    => true,
            'SYSTEM_USER'                => true,
            'TAN'                        => true,
            'TIME'                       => true,
            'TIMEDIFF'                   => true,
            'TIMESTAMP'                  => true,
            'TIMESTAMPADD'               => true,
            'TIMESTAMPDIFF'              => true,
            'TIME_FORMAT'                => true,
            'TIME_TO_SEC'                => true,
            'TOUCHES'                    => true,
            'TO_DAYS'                    => true,
            'TRIM'                       => true,
            'UCASE'                      => true,
            'UNCOMPRESS'                 => true,
            'UNCOMPRESSED_LENGTH'        => true,
            'UNHEX'                      => true,
            'UNIQUE_USERS'               => true,
            'UNIX_TIMESTAMP'             => true,
            'UPDATEXML'                  => true,
            'UPPER'                      => true,
            'USER'                       => true,
            'UTC_DATE'                   => true,
            'UTC_TIME'                   => true,
            'UTC_TIMESTAMP'              => true,
            'UUID'                       => true,
            'VARIANCE'                   => true,
            'VAR_POP'                    => true,
            'VAR_SAMP'                   => true,
            'VERSION'                    => true,
            'WEEK'                       => true,
            'WEEKDAY'                    => true,
            'WEEKOFYEAR'                 => true,
            'WITHIN'                     => true,
            'X'                          => true,
            'Y'                          => true,
            'YEAR'                       => true,
            'YEARWEEK'                   => true,
        ];

        $options += [
            // インデント文字
            'indent'    => "  ",
            // インラインレベル
            'inline'    => 999,
            // 括弧の展開レベル
            'nestlevel' => 1,
            // キーワードの大文字/小文字可変換（true だと大文字化。false だと小文字化。あるいは 'ucfirst' 等の文字列関数を直接指定する。クロージャでも良い）
            'case'      => null,
            // シンタックス装飾（true だと SAPI に基づいてよしなに。"html", "cli" だと SAPI を明示的に指定。クロージャだと直接コール）
            'highlight' => null,
            // 最大折返し文字数（未実装）
            'wrapsize'  => false,
        ];

        if ($options['case'] === true) {
            $options['case'] = 'strtoupper';
        }
        elseif ($options['case'] === false) {
            $options['case'] = 'strtolower';
        }

        if ($options['highlight'] === true) {
            $options['highlight'] = php_sapi_name() === 'cli' ? 'cli' : 'html';
        }
        if (is_string($options['highlight'])) {
            $rules = [
                'cli'  => [
                    'KEYWORD' => fn($token) => "\e[1m" . $token . "\e[m",
                    'COMMENT' => fn($token) => "\e[33m" . $token . "\e[m",
                    'STRING'  => fn($token) => "\e[31m" . $token . "\e[m",
                    'NUMBER'  => fn($token) => "\e[36m" . $token . "\e[m",
                ],
                'html' => [
                    'KEYWORD' => fn($token) => "<span style='font-weight:bold;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'COMMENT' => fn($token) => "<span style='color:#FF8000;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'STRING'  => fn($token) => "<span style='color:#DD0000;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'NUMBER'  => fn($token) => "<span style='color:#0000BB;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                ],
            ];
            $rule = $rules[$options['highlight']] ?? throws(new \InvalidArgumentException('highlight must be "cli" or "html".'));
            $options['highlight'] = function ($token, $ttype) use ($keywords, $rule) {
                switch (true) {
                    case isset($keywords[strtoupper($token)]):
                        return $rule['KEYWORD']($token);
                    case in_array($ttype, [T_COMMENT, T_DOC_COMMENT]):
                        return $rule['COMMENT']($token);
                    case in_array($ttype, [T_CONSTANT_ENCAPSED_STRING, T_ENCAPSED_AND_WHITESPACE]):
                        return $rule['STRING']($token);
                    case in_array($ttype, [T_LNUMBER, T_DNUMBER]):
                        return $rule['NUMBER']($token);
                }
                return $token;
            };
        }
        $options['syntaxer'] = function ($token, $ttype) use ($options, $keywords) {
            if (in_array($ttype, [T_COMMENT, T_DOC_COMMENT, T_CONSTANT_ENCAPSED_STRING], true)) {
                $tokens = [$token];
            }
            else {
                $tokens = explode(' ', $token);
            }

            $result = [];
            foreach ($tokens as $token) {
                if ($options['case'] && isset($keywords[strtoupper($token)])) {
                    $token = $options['case']($token);
                }
                if ($options['highlight']) {
                    $token = $options['highlight']($token, $ttype);
                }
                $result[] = $token;
            }
            return implode(' ', $result);
        };

        // 構文解析も先読みもない素朴な実装なので、特定文字列をあとから置換するための目印文字列
        $MARK = unique_string($sql, 8);
        $MARK_BR = "{$MARK}_BR:}"; // 改行マーク
        $MARK_CS = "{$MARK}_CS:}"; // コメント開始マーク
        $MARK_CE = "{$MARK}_CE:}"; // コメント終了マーク
        $MARK_NT = "{$MARK}_NT:}"; // インデントマーク
        $MARK_SP = "{$MARK}_SP:}"; // スペースマーク
        $MARK_PT = "{$MARK}_PT:}"; // 括弧ネストマーク

        // 字句にバラす（シンタックスが php に似ているので token_get_all で大幅にサボることができる）
        $tokens = [];
        $comment = '';
        $last = [];
        foreach (token_get_all("<?php $sql") as $token) {
            // トークンは配列だったり文字列だったりするので -1 トークンとして配列に正規化
            if (is_string($token)) {
                $token = [-1, $token];
            }

            // パースのために無理やり <?php を付けているので無視
            if ($token[0] === T_OPEN_TAG) {
                continue;
            }

            // '--' は php ではデクリメントだが sql ではコメントなので特別扱いする
            if ($token[0] === T_DEC) {
                $comment = $token[1];
            }
            // 改行は '--' コメントの終わり
            elseif ($comment && in_array($token[0], [T_WHITESPACE, T_COMMENT], true) && strpos($token[1], "\n") !== false) {
                $tokens[] = [T_COMMENT, $comment . $token[1]];
                $comment = '';
            }
            // コメント中はコメントに格納する
            elseif ($comment) {
                $comment .= $token[1];
            }
            // END IF, END LOOP などは一つのトークンとする
            elseif (strtoupper($last[1] ?? '') === 'END' && in_array(strtoupper($token[1]), ['CASE', 'IF', 'LOOP', 'REPEAT', 'WHILE'], true)) {
                $tokens[array_key_last($tokens)][1] .= " " . $token[1];
            }
            // 上記以外はただのトークンとして格納する
            else {
                // `string` のような文字列は T_ENCAPSED_AND_WHITESPACE として得られる（ただし ` がついていないので付与）
                if ($token[0] === T_ENCAPSED_AND_WHITESPACE) {
                    $tokens[] = [$token[0], "`{$token[1]}`"];
                }
                elseif ($token[0] !== T_WHITESPACE && $token[1] !== '`') {
                    $tokens[] = [$token[0], $token[1]];
                }
            }

            if ($token[0] !== T_WHITESPACE) {
                $last = $token;
            }
        }

        // コメント以外の前後のトークンを返すクロージャ
        $seek = function ($start, $step) use ($tokens) {
            $comments = [];
            for ($n = 1; ; $n++) {
                $index = $start + $n * $step;
                if (!isset($tokens[$index])) {
                    break;
                }
                $token = $tokens[$index];
                if ($token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT) {
                    $comments[] = trim($token[1]);
                }
                else {
                    return [$index, trim($token[1]), $comments];
                }
            }
            return [$start, '', $comments];
        };

        $interpret = function (&$index = -1, $context = '', $breaker = '', $nest = 0) use (&$interpret, $MARK_BR, $MARK_CS, $MARK_CE, $MARK_NT, $MARK_SP, $MARK_PT, $tokens, $options, $seek) {
            $index++;
            $beginning = true; // クエリの冒頭か
            $subcontext = '';  // SET, VALUES などのサブ分類
            $modifier = '';    // RIGHT などのキーワード修飾語
            $firstcol = null;  // SELECT における最初の列か

            $result = [];
            for ($token_length = count($tokens); $index < $token_length; $index++) {
                $token = $tokens[$index];
                $ttype = $token[0];

                $rawtoken = trim($token[1]);
                $virttoken = $options['syntaxer']($rawtoken, $ttype);
                $uppertoken = strtoupper($rawtoken);

                // SELECT の直後には DISTINCT などのオプションが来ることがあるので特別扱い
                if ($context === 'SELECT' && $firstcol) {
                    if (!in_array($uppertoken, ['DISTINCT', 'DISTINCTROW', 'STRAIGHT_JOIN'], true) && !preg_match('#^SQL_#i', $uppertoken)) {
                        $firstcol = false;
                        $result[] = $MARK_BR;
                    }
                }

                // コメントは特別扱いでただ付け足すだけ
                if ($ttype === T_COMMENT || $ttype === T_DOC_COMMENT) {
                    $result[] = ($beginning ? '' : $MARK_CS) . $virttoken . $MARK_CE . $MARK_BR;
                    continue;
                }

                $prev = $seek($index, -1);
                $next = $seek($index, +1);

                switch ($uppertoken) {
                    default:
                        _DEFAULT:
                        // "tablename. columnname" になってしまう
                        // "@ var" になってしまう
                        // ": holder" になってしまう
                        if (!in_array($prev[1], ['.', '@', ':', ';'])) {
                            $result[] = $MARK_SP;
                        }

                        $result[] = $virttoken;

                        // "tablename .columnname" になってしまう
                        // "columnname ," になってしまう
                        // mysql において関数呼び出し括弧の前に空白は許されない
                        // ただし、関数呼び出しではなく記号の場合はスペースを入れたい（ colname = (SELECT ～) など）
                        if (!in_array($next[1], ['.', ',', '(', ';']) || ($next[1] === '(' && !preg_match('#^[a-z0-9_"\'`]+$#i', $rawtoken))) {
                            $result[] = $MARK_SP;
                        }
                        break;
                    case "@":
                    case ":":
                        $result[] = $MARK_SP . $virttoken;
                        break;
                    case ".":
                        $result[] = $virttoken;
                        break;
                    case ",":
                        if ($subcontext === 'LIMIT') {
                            $result[] = $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case ";":
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case "WITH":
                        $result[] = $virttoken;
                        $result[] = $MARK_BR;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "BETWEEN":
                        $subcontext = $uppertoken;
                        goto _DEFAULT;
                    case "CREATE":
                    case "ALTER":
                    case "DROP":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $context = $uppertoken;
                        break;
                    case "TABLE":
                        // CREATE TABLE tablename は括弧があるので何もしなくて済むが、
                        // ALTER TABLE tablename は括弧がなく ADD などで始まるので特別分岐
                        $index = $next[0];
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . ($MARK_SP . implode('', $next[2]) . $MARK_CE) . $next[1] . $MARK_SP;
                        if ($context !== 'CREATE' && $context !== 'DROP') {
                            $result[] = $MARK_BR;
                        }
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "AND":
                        // BETWEEN A AND B と論理演算子の AND が競合するので分岐後にフォールスルー
                        if ($subcontext === 'BETWEEN') {
                            $subcontext = '';
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        goto _BINARY_OPERATOR_;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "OR":
                        // CREATE OR REPLACE
                        if ($context === 'CREATE') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        goto _BINARY_OPERATOR_;
                    case "XOR":
                        _BINARY_OPERATOR_:
                        // WHEN の条件はカッコがない限り改行しない
                        if ($subcontext === 'WHEN') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $MARK_SP . $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "UNION":
                    case "EXCEPT":
                    case "INTERSECT":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        $result[] = $MARK_BR;
                        break;
                    case "BY":
                    case "ALL":
                    case "RECURSIVE":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . array_pop($result);
                        break;
                    case "SELECT":
                        if (!$beginning) {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        $context = $uppertoken;
                        $firstcol = true;
                        break;
                    case "LEFT":
                        /** @noinspection PhpMissingBreakStatementInspection */
                    case "RIGHT":
                        // 例えば LEFT や RIGHT は関数呼び出しの場合もあるので分岐後にフォールスルー
                        if ($next[1] === '(') {
                            goto _DEFAULT;
                        }
                    case "CROSS":
                    case "INNER":
                    case "OUTER":
                        $modifier .= $virttoken . $MARK_SP;
                        break;
                    case "FROM":
                    case "JOIN":
                    case "WHERE":
                    case "HAVING":
                    case "GROUP":
                    case "ORDER":
                    case "LIMIT":
                    case "OFFSET":
                        $subcontext = $uppertoken;
                        $result[] = $MARK_BR . $modifier . $virttoken;
                        $result[] = $MARK_BR; // のちの BY のために結合はせず後ろに入れるだけにする
                        $modifier = '';
                        break;
                    case "FOR":
                    case "LOCK":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        break;
                    case "ON":
                        // ON は ON でも mysql の ON DUPLICATED かもしれない（pgsql の ON CONFLICT も似たようなコンテキスト）
                        if (in_array(strtoupper($next[1]), ['DUPLICATE', 'CONFLICT'], true)) {
                            $result[] = $MARK_BR;
                        }
                        else {
                            $result[] = $MARK_SP;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "SET":
                        if ($context === "INSERT" || $context === "UPDATE") {
                            $subcontext = $uppertoken;
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        elseif ($context === "ALTER" || $subcontext === "REFERENCES") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $virttoken;
                        }
                        break;
                    case "INSERT":
                    case "REPLACE":
                        $result[] = $virttoken . $MARK_SP;
                        $context = "INSERT"; // 構文的には INSERT と同じ
                        break;
                    case "INTO":
                        if ($context === "SELECT") {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        if ($context === "INSERT") {
                            $result[] = $MARK_BR;
                        }
                        break;
                    case "VALUES":
                        if ($context === "UPDATE") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        break;
                    case "REFERENCES":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $subcontext = $uppertoken;
                        break;
                    case "UPDATE":
                    case "DELETE":
                        $result[] = $virttoken;
                        if ($context !== 'CREATE' && $subcontext !== 'REFERENCES') {
                            $result[] = $MARK_BR;
                            $context = $uppertoken;
                        }
                        break;
                    case "IF":
                        $subcontext = $uppertoken;
                        $result[] = $virttoken;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "WHEN":
                        $subcontext = $uppertoken;
                        $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "ELSE":
                        if ($context === 'CASE') {
                            $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "CASE":
                        $parts = $interpret($index, $uppertoken, 'END', $nest + 1);
                        $parts = str_replace($MARK_BR, $MARK_BR . $MARK_NT, $parts);
                        $result[] = $MARK_NT . $virttoken . $MARK_SP . $parts;
                        break;
                    case "BEGIN":
                        if ($next[1] === ';') {
                            $result[] = $virttoken;
                        }
                        else {
                            $parts = $interpret($index, $uppertoken, 'END', $nest + 1);
                            $parts = preg_replace("#^($MARK_SP)+#u", "", $parts);
                            $parts = preg_replace("#$MARK_BR#u", $MARK_BR . $MARK_NT, $parts, substr_count($parts, $MARK_BR) - 1);
                            $result[] = $MARK_BR . $virttoken . $MARK_BR . $MARK_NT . $parts;
                        }
                        break;
                    case "END":
                        if ($context === 'CASE') {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        break;
                    case "(":
                        if ($next[1] === ')') {
                            $result[] = $virttoken . implode('', $next[2]) . ')';
                            $index = $next[0];
                            break;
                        }

                        $parts = $uppertoken . $MARK_BR . $interpret($index, $uppertoken, ')', $nest + 1);

                        // コメントを含まない指定ネストレベルなら改行とインデントを吹き飛ばす
                        if (strpos($parts, $MARK_CE) === false && ($nest >= $options['inline'] || substr_count($parts, $MARK_PT) < $options['nestlevel'])) {
                            $parts = strtr($parts, [
                                $MARK_BR => "",
                                $MARK_NT => "",
                            ]);
                            $parts = preg_replace("#\\(($MARK_SP)+#u", '(', $parts);
                            $parts = preg_replace("#($MARK_SP)+\\)#u", ')', $parts);
                        }
                        elseif ($context === 'CREATE') {
                            // ???
                            assert($context === 'CREATE');
                        }
                        else {
                            $lastnt = $MARK_NT;
                            $brnt = $MARK_BR . $MARK_NT;
                            if (strtoupper($next[1]) === 'SELECT') {
                                $brnt .= $lastnt;
                            }
                            $parts = preg_replace("#($MARK_BR(?!\\)))+#u", $brnt, $parts) . $lastnt;
                            $parts = preg_replace("#($MARK_BR(\\)))+#u", "$MARK_BR$MARK_NT)", $parts) . $lastnt;
                            $parts = preg_replace("#$MARK_CS#u", "", $parts);
                        }

                        // IN や数式はネストとみなさない
                        $suffix = $MARK_PT;
                        if (strtoupper($prev[1]) === 'IN' || !preg_match('#^[a-z0-9_]+$#i', $prev[1])) {
                            $suffix = '';
                        }

                        $result[] = $MARK_NT . $parts . $suffix;
                        break;
                    case ")":
                        $result[] = $MARK_BR . $virttoken;
                        break;
                }

                $beginning = false;

                if ($uppertoken === $breaker) {
                    break;
                }
            }
            return implode('', $result);
        };

        $result = $interpret();
        $result = preg_replaces("#" . implode('|', [
                // 改行文字＋インデント文字をインデントとみなす（改行＋連続スペースもついでに）
                "(?<indent>$MARK_BR(($MARK_NT|$MARK_SP)+))",
                // 末尾スペースは除去
                "(?<spbr>($MARK_SP)+(?=$MARK_BR))",
                // 行末コメントと単一コメント
                "(?<cs1>$MARK_BR$MARK_CS)",
                "(?<cs2>$MARK_CS)",
                // 連続改行は1つに集約
                "(?<br>$MARK_BR(($MARK_NT|$MARK_SP)*)($MARK_BR)*)",
                // 連続スペースは1つに集約
                "(?<sp>($MARK_SP)+)",
                // 下記はマーカ文字が現れないように単純置換
                "(?<ce>$MARK_CE)",
                "(?<nt>$MARK_NT)",
                "(?<pt>$MARK_PT)",
            ]) . "#u", [
            'indent' => fn($str) => "\n" . str_repeat($options['indent'], (substr_count($str, $MARK_NT) + substr_count($str, $MARK_SP))),
            'spbr'   => "",
            'cs1'    => "\n" . $options['indent'],
            'cs2'    => "",
            'br'     => "\n",
            'sp'     => ' ',
            'ce'     => "",
            'nt'     => "",
            'pt'     => "",
        ], $result);

        return trim($result);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\sql_quote') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\sql_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\sql_quote')) {
    /**
     * ものすごく雑に値をクオートする
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた値で**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * - null は NULL になる
     * - 数字はそのまま数字になる
     * - bool は 0 or 1 になる
     * - 配列は再帰的にカンマ区切りになる
     *   - この実装はエラー回避の意味合いが強く、実装は変更される可能性がある
     * - それ以外は addcslashes される
     *
     * Example:
     * ```php
     * that(sql_quote(null))->isSame('NULL');
     * that(sql_quote(123))->isSame(123);
     * that(sql_quote(true))->isSame(1);
     * that(sql_quote("hoge"))->isSame("'hoge'");
     * that(sql_quote([1, 2, 3]))->isSame("1,2,3");
     * ```
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param mixed $value クオートする値
     * @return mixed クオートされた値
     */
    function sql_quote($value)
    {
        if ($value === null) {
            return 'NULL';
        }
        if (is_numeric($value)) {
            return $value;
        }
        if (is_bool($value)) {
            return (int) $value;
        }
        if (is_iterable($value) && !is_stringable($value)) {
            return implode(',', array_map(fn($v) => sql_quote($v), arrayval($value)));
        }
        return "'" . addcslashes((string) $value, "\0\e\f\n\r\t\v'\\") . "'";
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\markdown_table') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\markdown_table'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\markdown_table')) {
    /**
     * 連想配列の配列を markdown テーブル文字列にする
     *
     * 見出しはキーの和集合で生成され、改行は `<br>` に置換される。
     * 要素が全て数値の場合は右寄せになる。
     *
     * Example:
     * ```php
     * // 最初の "\n" に意味はない（ズレると見づらいので冒頭に足しているだけ）
     * that("\n" . markdown_table([
     *    ['a' => 'a1', 'b' => 'b1'],
     *    ['b' => 'b2', 'c' => '2'],
     *    ['a' => 'a3', 'c' => '3'],
     * ]))->is("
     * | a   | b   |   c |
     * | --- | --- | --: |
     * | a1  | b1  |     |
     * |     | b2  |   2 |
     * | a3  |     |   3 |
     * ");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param array $array 連想配列の配列
     * @param array $option オプション配列
     * @return string markdown テーブル文字列
     */
    function markdown_table($array, $option = [])
    {
        if (!is_array($array) || is_empty($array)) {
            throw new \InvalidArgumentException('$array must be array of hasharray.');
        }

        $option += [
            'keylabel'  => null,   // 指定すると一番左端にキーの列が生える
            'context'   => 'html', // html:改行がbrになる（html 以外は未定義）
            'stringify' => fn($v) => var_pretty($v, ['return' => true, 'context' => $option['context'], 'table' => false]),
        ];

        $stringify = fn($v) => strtr(trim(is_stringable($v) ? $v : $option['stringify']($v)), ["\t" => '    ']);

        $rows = [];
        $defaults = [];
        $numerics = [];
        $lengths = [];
        foreach ($array as $n => $fields) {
            assert(is_array($fields), '$array must be array of hasharray.');
            if ($option['keylabel'] !== null) {
                $fields = [$option['keylabel'] => $n] + $fields;
            }
            if ($option['context'] === 'html') {
                $fields = array_map(fn($v) => (array) str_replace(["\r\n", "\r", "\n"], '<br>', $stringify($v)), $fields);
            }
            else {
                $fields = array_map(fn($v) => preg_split("#\r?\n#u", $stringify($v)), $fields);
            }
            foreach ($fields as $k => $v) {
                $defaults[$k] = '';
                foreach ($v as $i => $t) {
                    $e = ansi_strip($t);
                    $rows["{$n}_{$i}"][$k] = $t;
                    $numerics[$k] = ($numerics[$k] ?? true) && (is_numeric($e) || strlen($e) === 0);
                    $lengths[$k] = max($lengths[$k] ?? 3, mb_monospace(ansi_strip($k)), mb_monospace($e)); // 3 は markdown の最低見出し長
                }
            }
        }

        $linebuilder = function ($fields, $padstr) use ($numerics, $lengths) {
            $line = [];
            foreach ($fields as $k => $v) {
                $ws = str_repeat($padstr, $lengths[$k] - (mb_monospace(ansi_strip($v))));
                $pad = $numerics[$k] ? "$ws$v" : "$v$ws";
                if ($padstr === '-' && $numerics[$k]) {
                    $pad[-1] = ':';
                }
                $line[] = $pad;
            }
            return '| ' . implode(' | ', $line) . ' |';
        };

        $result = [];

        $result[] = $linebuilder(array_combine($keys = array_keys($defaults), $keys), ' ');
        $result[] = $linebuilder($defaults, '-');
        foreach ($rows as $fields) {
            $result[] = $linebuilder(array_replace($defaults, $fields), ' ');
        }

        return implode("\n", $result) . "\n";
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\date_timestamp') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\date_timestamp'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\date_timestamp')) {
    /**
     * 日時的なものをよしなにタイムスタンプに変換する
     *
     * マイクロ秒にも対応している。つまり返り値は int か float になる。
     * また、相対指定の +1 month の月末問題は起きないようにしてある。
     *
     * かなり適当に和暦にも対応している。
     * さらに必要に迫られてかなり特殊な対応を行っているので Example を参照。
     *
     * Example:
     * ```php
     * // 普通の日時文字列
     * that(date_timestamp('2014/12/24 12:34:56'))->isSame(strtotime('2014/12/24 12:34:56'));
     * // 和暦
     * that(date_timestamp('昭和31年12月24日 12時34分56秒'))->isSame(strtotime('1956/12/24 12:34:56'));
     * // 相対指定
     * that(date_timestamp('2012/01/31 +1 month'))->isSame(strtotime('2012/02/29'));
     * that(date_timestamp('2012/03/31 -1 month'))->isSame(strtotime('2012/02/29'));
     * // マイクロ秒
     * that(date_timestamp('2014/12/24 12:34:56.789'))->isSame(1419392096.789);
     *
     * // ベース日時
     * $baseTimestamp = strtotime('2012/01/31');
     * // ベース日時の25日（strtotime の序数日付は first/last しか対応していないが、この関数は対応している）
     * that(date_timestamp('25th of this month', $baseTimestamp))->isSame(strtotime('2012/01/25'));
     * // ベース日時の第2月曜（strtotime の序数曜日は 1st のような表記に対応していないが、この関数は対応している）
     * that(date_timestamp('2nd monday of this month', $baseTimestamp))->isSame(strtotime('2012/01/09'));
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string|int|float|\DateTimeInterface $datetimedata 日時データ
     * @param int|null $baseTimestamp 日時データ
     * @return int|float|null タイムスタンプ。パース失敗時は null
     */
    function date_timestamp($datetimedata, $baseTimestamp = null)
    {
        if ($datetimedata instanceof \DateTimeInterface) {
            return $datetimedata->getTimestamp() + $datetimedata->format('u') / 1000 / 1000;
        }

        $DAY1 = 60 * 60 * 24;
        $ORDINAL_WORDS = [
            '1st'  => 'first',
            '2nd'  => 'second',
            '3rd'  => 'third',
            '4th'  => 'fourth',
            '5th'  => 'fifth',
            '6th'  => 'sixth',
            '7th'  => 'seventh',
            '8th'  => 'eighth',
            '9th'  => 'ninth',
            '10th' => 'tenth',
            '11th' => 'eleventh',
            '12th' => 'twelfth',
        ];

        $ordinal_day = null;
        $oddeven = null;
        if (is_string($datetimedata) || (is_object($datetimedata) && method_exists($datetimedata, '__toString'))) {
            // 全角を含めた trim
            $chars = "[\\x0-\x20\x7f\xc2\xa0\xe3\x80\x80]";
            $datetimedata = preg_replace("/\A{$chars}++|{$chars}++\z/u", '', $datetimedata);

            // 和暦を西暦に置換
            $jpnames = array_merge(array_column(JP_ERA, 'name'), array_column(JP_ERA, 'abbr'));
            $datetimedata = preg_replace_callback('/^(' . implode('|', $jpnames) . ')(\d{1,2}|元)/u', function ($matches) {
                [, $era, $year] = $matches;
                $eratime = array_find(JP_ERA, function ($v) use ($era) {
                    if (in_array($era, [$v['name'], $v['abbr']], true)) {
                        return $v['since'];
                    }
                }, false);
                return idate('Y', $eratime) + ($year === '元' ? 1 : $year) - 1;
            }, $datetimedata);

            // 単位文字列を置換
            $datetimedata = strtr($datetimedata, [
                '　'    => ' ',
                '西暦' => '',
                '年'   => '/',
                '月'   => '/',
                '日'   => ' ',
                '時'   => ':',
                '分'   => ':',
                '秒'   => '',
            ]);
            $datetimedata = trim($datetimedata, " \t\n\r\0\x0B:/");

            // 1st, 2nd, 3rd, 4th dayname の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+(sun|mon|tues?|wed(nes)?|thu(rs)?|fri|sat(ur)?)day)#u', function ($matches) use ($ORDINAL_WORDS) {
                if (!isset($ORDINAL_WORDS[$matches[1]])) {
                    return $matches[0];
                }

                return $ORDINAL_WORDS[$matches[1]] . $matches[4];
            }, $datetimedata);

            // 1st, 2nd, 3rd, 4th day の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+day)?#ui', function ($matches) use (&$ordinal_day) {
                if ($matches[1] !== (new \NumberFormatter('en', \NumberFormatter::ORDINAL))->format($matches[2])) {
                    return $matches[0];
                }

                $ordinal_day = $matches[2];
                return 'first day';
            }, $datetimedata);

            // odd, even の対応
            $datetimedata = preg_replace_callback('#(odd|even)\s+#ui', function ($matches) use (&$oddeven) {
                $oddeven = $matches[1];
                return 'this ';
            }, $datetimedata);
        }

        // 数値4桁は年と解釈されるように
        if (preg_match('/^[0-9]{4}$/', $datetimedata)) {
            $datetimedata .= '-01-01';
        }

        // 数値系はタイムスタンプとみなす
        if (ctype_digit("$datetimedata")) {
            return (int) $datetimedata;
        }
        if (is_numeric($datetimedata)) {
            return (float) $datetimedata;
        }

        // strtotime と date_parse の合せ技で変換
        $baseTimestamp ??= time();
        $timestamp = strtotime($datetimedata, $baseTimestamp);
        $parts = date_parse($datetimedata);
        if ($timestamp === false || $parts['error_count']) {
            return null;
        }

        if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
            if (!isset($parts['relative'])) {
                return null;
            }
            $parts['year'] = idate('Y', $baseTimestamp);
            $parts['month'] = idate('m', $baseTimestamp);
            $parts['day'] = idate('d', $baseTimestamp);
        }

        if ($ordinal_day) {
            $timestamp += ($ordinal_day - 1) * $DAY1;
        }

        if ($oddeven !== null) {
            $idateW2 = idate('W', $timestamp) % 2;
            if (($oddeven === 'odd' && $idateW2 === 0) || ($oddeven === 'even' && $idateW2 === 1)) {
                $timestamp += $DAY1 * 7;
            }
        }

        $relative = $parts['relative'] ?? [];
        if (($relative['month'] ?? false)
            && !isset($relative['weekday'])            // 週指定があるとかなり特殊で初日末日が意味を為さない
            && !isset($relative['first_day_of_month']) // first day 指定があるなら初日確定
            && !isset($relative['last_day_of_month'])  // last day 指定があるなら末日確定
        ) {
            $parts['month'] += $relative['month'];
            $parts['year'] += intdiv($parts['month'], 12);
            $parts['month'] %= 12;
            $parts['month'] += $parts['month'] <= 0 ? 12 : 0;

            if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
                $timestamp = strtotime(date('Y-m-t H:i:s', $timestamp - $DAY1 * 4));
            }
        }

        if ($parts['fraction']) {
            $timestamp += ($timestamp >= 0 ? +$parts['fraction'] : -$parts['fraction']);
        }
        return $timestamp;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\backtrace') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\backtrace'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\backtrace')) {
    /**
     * 特定条件までのバックトレースを取得する
     *
     * 第2引数 $options を満たすトレース以降を返す。
     * $options は ['$trace の key' => "条件"] を渡す。
     * 条件は文字列かクロージャで、文字列の場合は緩い一致、クロージャの場合は true を返した場合にそれ以降を返す。
     *
     * Example:
     * ```php
     * function f001 () {return backtrace(0, ['function' => __NAMESPACE__ . '\\f002', 'limit' => 2]);}
     * function f002 () {return f001();}
     * function f003 () {return f002();}
     * $traces = f003();
     * // limit 指定してるので2個
     * that($traces)->count(2);
     * // 「function が f002 以降」を返す
     * that($traces[0])->subsetEquals([
     *     'function' => __NAMESPACE__ . '\\f002'
     * ]);
     * that($traces[1])->subsetEquals([
     *     'function' => __NAMESPACE__ . '\\f003'
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param int $flags debug_backtrace の引数
     * @param array $options フィルタ条件
     * @return array バックトレース
     */
    function backtrace($flags = \DEBUG_BACKTRACE_PROVIDE_OBJECT, $options = [])
    {
        $result = [];
        $traces = debug_backtrace($flags);
        foreach ($traces as $n => $trace) {
            foreach ($options as $key => $val) {
                if (!isset($trace[$key])) {
                    continue;
                }

                if ($val instanceof \Closure) {
                    $break = $val($trace[$key]);
                }
                else {
                    $break = $trace[$key] == $val;
                }
                if ($break) {
                    $result = array_slice($traces, $n);
                    break 2;
                }
            }
        }

        // offset, limit は特別扱いで千切り指定
        if (isset($options['offset']) || isset($options['limit'])) {
            $result = array_slice($result, $options['offset'] ?? 0, $options['limit'] ?? count($result));
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\stacktrace') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\stacktrace'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\stacktrace')) {
    /**
     * スタックトレースを文字列で返す
     *
     * `(new \Exception())->getTraceAsString()` と実質的な役割は同じ。
     * ただし、 getTraceAsString は引数が Array になったりクラス名しか取れなかったり微妙に使い勝手が悪いのでもうちょっと情報量を増やしたもの。
     *
     * 第1引数 $traces はトレース的配列を受け取る（`(new \Exception())->getTrace()` とか）。
     * 未指定時は debug_backtrace() で採取する。
     *
     * 第2引数 $option は文字列化する際の設定を指定する。
     * 情報量が増える分、機密も含まれる可能性があるため、 mask オプションで塗りつぶすキーや引数名を指定できる（クロージャの引数までは手出ししないため留意）。
     * limit と format は比較的指定頻度が高いかつ互換性維持のため配列オプションではなく直に渡すことが可能になっている。
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param ?array $traces debug_backtrace 的な配列
     * @param int|string|array $option オプション
     * @return string|array トレース文字列（delimiter オプションに null を渡すと配列で返す）
     */
    function stacktrace($traces = null, $option = [])
    {
        if (is_int($option)) {
            $option = ['limit' => $option];
        }
        elseif (is_string($option)) {
            $option = ['format' => $option];
        }

        $option += [
            'format'    => '%s:%s %s', // 文字列化するときの sprintf フォーマット
            'args'      => true,       // 引数情報を埋め込むか否か
            'limit'     => 16,         // 配列や文字列を千切る長さ
            'delimiter' => "\n",       // スタックトレースの区切り文字（null で配列になる）
            'mask'      => ['#^password#', '#^secret#', '#^credential#', '#^credit#'],
        ];
        $limit = $option['limit'];
        $maskregexs = (array) $option['mask'];
        $mask = static function ($key, $value) use ($maskregexs) {
            if (!is_string($value)) {
                return $value;
            }
            foreach ($maskregexs as $regex) {
                if (preg_match($regex, $key)) {
                    return str_repeat('*', strlen($value));
                }
            }
            return $value;
        };

        $stringify = static function ($value) use ($limit, $mask) {
            // 再帰用クロージャ
            $export = static function ($value, $nest = 0, $parents = []) use (&$export, $limit, $mask) {
                // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
                foreach ($parents as $parent) {
                    if ($parent === $value) {
                        return var_export('*RECURSION*', true);
                    }
                }
                // 配列は連想判定したり再帰したり色々
                if (is_array($value)) {
                    $parents[] = $value;
                    $flat = $value === array_values($value);
                    $kvl = [];
                    foreach ($value as $k => $v) {
                        if (count($kvl) >= $limit) {
                            $kvl[] = sprintf('...(more %d length)', count($value) - $limit);
                            break;
                        }
                        $kvl[] = ($flat ? '' : $k . ':') . $export(call_user_func($mask, $k, $v), $nest + 1, $parents);
                    }
                    return ($flat ? '[' : '{') . implode(', ', $kvl) . ($flat ? ']' : '}');
                }
                // オブジェクトは単にプロパティを配列的に出力する
                elseif (is_object($value)) {
                    $parents[] = $value;
                    return get_class($value) . $export(get_object_properties($value), $nest, $parents);
                }
                // 文字列は改行削除
                elseif (is_string($value)) {
                    $value = str_replace(["\r\n", "\r", "\n"], '\n', $value);
                    if (($strlen = strlen($value)) > $limit) {
                        $value = substr($value, 0, $limit) . sprintf('...(more %d length)', $strlen - $limit);
                    }
                    return '"' . addcslashes($value, "\"\0\\") . '"';
                }
                // それ以外は stringify
                else {
                    return stringify($value);
                }
            };

            return $export($value);
        };

        $traces ??= array_slice(debug_backtrace(), 1);
        $result = [];
        foreach ($traces as $i => $trace) {
            // メソッド内で関数定義して呼び出したりすると file が無いことがある（かなりレアケースなので無視する）
            if (!isset($trace['file'])) {
                continue; // @codeCoverageIgnore
            }

            $file = $trace['file'];
            $line = $trace['line'];
            if (strpos($trace['file'], "eval()'d code") !== false && ($traces[$i + 1]['function'] ?? '') === 'eval') {
                $file = $traces[$i + 1]['file'];
                $line = $traces[$i + 1]['line'] . "." . $trace['line'];
            }

            if (isset($trace['type'])) {
                $callee = $trace['class'] . $trace['type'] . $trace['function'];
                if ($option['args'] && $maskregexs && method_exists($trace['class'], $trace['function'])) {
                    $ref = new \ReflectionMethod($trace['class'], $trace['function']);
                }
            }
            else {
                $callee = $trace['function'];
                if ($option['args'] && $maskregexs && function_exists($callee)) {
                    $ref = new \ReflectionFunction($trace['function']);
                }
            }
            $args = [];
            if ($option['args']) {
                $args = $trace['args'] ?? [];
                if (isset($ref)) {
                    $params = $ref->getParameters();
                    foreach ($params as $n => $param) {
                        if (array_key_exists($n, $args)) {
                            $args[$n] = $mask($param->getName(), $args[$n]);
                        }
                    }
                }
            }
            $callee .= '(' . implode(', ', array_map($stringify, $args)) . ')';

            $result[] = sprintf($option['format'], $file, $line, $callee);
        }
        if ($option['delimiter'] === null) {
            return $result;
        }
        return implode($option['delimiter'], $result);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\dirname_r') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\dirname_r'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\dirname_r')) {
    /**
     * コールバックが true 相当を返すまで親ディレクトリを辿り続ける
     *
     * コールバックには親ディレクトリが引数として渡ってくる。
     *
     * Example:
     * ```php
     * // //tmp/a/b/file.txt を作っておく
     * $tmp = sys_get_temp_dir();
     * file_set_contents("$tmp/a/b/file.txt", 'hoge');
     * // /a/b/c/d/e/f から開始して「どこかの階層の file.txt を探したい」という状況を想定
     * $callback = fn($path) => realpath("$path/file.txt");
     * that(dirname_r("$tmp/a/b/c/d/e/f", $callback))->isSame(realpath("$tmp/a/b/file.txt"));
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス名
     * @param callable $callback コールバック
     * @return mixed $callback の返り値。頂上まで辿ったら false
     */
    function dirname_r($path, $callback)
    {
        $return = $callback($path);
        if ($return) {
            return $return;
        }

        $dirname = dirname($path);
        if ($dirname === $path) {
            return false;
        }
        return dirname_r($dirname, $callback);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\file_list') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\file_list'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\file_list')) {
    /**
     * ファイル一覧を配列で返す
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $DS = DIRECTORY_SEPARATOR;
     * $tmp = sys_get_temp_dir() . "{$DS}file_list";
     * rm_rf($tmp, false);
     * file_set_contents("$tmp/a.txt", 'a');
     * file_set_contents("$tmp/dir/b.txt", 'b');
     * file_set_contents("$tmp/dir/dir/c.txt", 'c');
     * // ファイル一覧が取得できる
     * that(file_list($tmp))->equalsCanonicalizing([
     *     "$tmp{$DS}a.txt",
     *     "$tmp{$DS}dir{$DS}b.txt",
     *     "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname 調べるディレクトリ名
     * @param array $filter_condition フィルタ条件
     * @return array|false ファイルの配列
     */
    function file_list($dirname, $filter_condition = [])
    {
        $filter_condition += [
            'unixpath' => false,
            '!type'    => 'dir',

            'recursive' => true,
            'relative'  => false,
            'nesting'   => false,
        ];

        $dirname = path_normalize($dirname);

        $subpath = '';
        while (!is_dir($dirname) && str_exists(basename($dirname), ['*', '?', '!', '{', '}', '[', ']'])) {
            $subpath = basename($dirname) . (strlen($subpath) ? '/' : '') . $subpath;
            $dirname = dirname($dirname);
        }

        if (strlen($subpath)) {
            if (strlen($filter_condition['subpath'] ?? '')) {
                throw new \InvalidArgumentException("both subpath and subpattern are specified");
            }
            $filter_condition['subpath'] = $subpath;
            $filter_condition['fnmflag'] = FNM_PATHNAME;
            $filter_condition['unixpath'] = true;
        }

        if (!file_exists($dirname) || $dirname === dirname($dirname)) {
            return false;
        }

        $match = file_matcher($filter_condition);

        $DS = DIRECTORY_SEPARATOR;
        $opt = \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::KEY_AS_PATHNAME | \FilesystemIterator::CURRENT_AS_SELF;

        if ($filter_condition['unixpath']) {
            $DS = '/';
            $opt |= \FilesystemIterator::UNIX_PATHS;
        }

        $rdi = new \RecursiveDirectoryIterator($dirname, $opt);

        if ($filter_condition['recursive']) {
            $iterator = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);
        }
        else {
            $iterator = $rdi;
        }

        $result = [];
        foreach ($iterator as $fullpath => $it) {
            if (!$match($it)) {
                continue;
            }

            $path = $filter_condition['relative'] ? $it->getSubPathName() : $fullpath;
            $path = strtr(is_dir($fullpath) ? $path . $DS : $path, [DIRECTORY_SEPARATOR => $DS]);

            if ($filter_condition['nesting']) {
                $tmp = &$result;
                foreach (array_filter(multiexplode(['/', DIRECTORY_SEPARATOR], $it->getSubPath()), 'strlen') as $subdir) {
                    $tmp = &$tmp[$subdir];
                }
                if ($it->isDir()) {
                    $tmp[$it->getFilename()] = $tmp[$it->getFilename()] ?? [];
                }
                else {
                    $tmp[$it->getFilename()] = $path;
                }
            }
            else {
                $result[] = $path;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\file_matcher') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\file_matcher'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\file_matcher')) {
    /**
     * 各種属性を指定してファイルのマッチングを行うクロージャを返す
     *
     * ※ 内部向け
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array $filter_condition マッチャーコンディション配列（ソースを参照）
     * @return \Closure ファイルマッチャー
     */
    function file_matcher(array $filter_condition)
    {
        $filter_condition += [
            // common
            'dotfile'    => null,  // switch startWith "."
            'unixpath'   => true,  // convert "\\" -> "/"
            'casefold'   => false, // ignore case
            'fnmflag'    => 0,     // FNM_*
            // by getType (string or [string])
            'type'       => null,
            '!type'      => null,
            // by getPerms (int)
            'perms'      => null,
            '!perms'     => null,
            // by getMTime (int or [int, int])
            'mtime'      => null,
            '!mtime'     => null,
            // by getSize (int or [int, int])
            'size'       => null,
            '!size'      => null,
            // by getPathname (glob or regex)
            'path'       => null,
            '!path'      => null,
            // by getSubPath (glob or regex)
            'subpath'    => null,
            '!subpath'   => null,
            // by getPath or getSubpath (glob or regex)
            'dir'        => null,
            '!dir'       => null,
            // by getFilename (glob or regex)
            'name'       => null,
            '!name'      => null,
            // by getBasename (glob or regex)
            'basename'   => null,
            '!basename'  => null,
            // by getExtension (string or [string])
            'extension'  => null,
            '!extension' => null,
            // by contents (string)
            'contains'   => null,
            '!contains'  => null,
            // by custom condition (callable)
            'filter'     => null,
            '!filter'    => null,
        ];

        foreach ([
            'mtime'  => fn(...$args) => date_timestamp(...$args),
            '!mtime' => fn(...$args) => date_timestamp(...$args),
            'size'   => fn(...$args) => si_unprefix(...$args),
            '!size'  => fn(...$args) => si_unprefix(...$args),
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $range = $filter_condition[$key];
                if (!is_array($range)) {
                    $range = array_fill_keys([0, 1], $range);
                }
                $range = array_map($map, $range);
                $filter_condition[$key] = static function ($value) use ($range) {
                    return (!isset($range[0]) || $value >= $range[0]) && (!isset($range[1]) || $value <= $range[1]);
                };
            }
        }

        foreach ([
            'type'       => null,
            '!type'      => null,
            'extension'  => null,
            '!extension' => null,
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $array = array_flip((array) $filter_condition[$key]);
                if ($filter_condition['casefold']) {
                    $array = array_change_key_case($array, CASE_LOWER);
                }
                $filter_condition[$key] = static function ($value) use ($array) {
                    return isset($array[$value]);
                };
            }
        }

        foreach ([
            'path'      => null,
            '!path'     => null,
            'subpath'   => null,
            '!subpath'  => null,
            'dir'       => null,
            '!dir'      => null,
            'name'      => null,
            '!name'     => null,
            'basename'  => null,
            '!basename' => null,
        ] as $key => $convert) {
            if (isset($filter_condition[$key])) {
                $callback = fn() => false;
                foreach (arrayize($filter_condition[$key]) as $pattern) {
                    preg_match('##', ''); // clear preg_last_error
                    @preg_match($pattern, '');
                    if (preg_last_error() === PREG_NO_ERROR) {
                        $callback = static function ($string) use ($callback, $pattern, $filter_condition) {
                            if ($callback($string)) {
                                return true;
                            }
                            $string = $filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\' ? str_replace('\\', '/', $string) : $string;
                            return !!preg_match($pattern, $string);
                        };
                    }
                    else {
                        $callback = static function ($string) use ($callback, $pattern, $filter_condition) {
                            if ($callback($string)) {
                                return true;
                            }
                            if ($filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\') {
                                $pattern = str_replace('\\', '/', $pattern);
                                $string = str_replace('\\', '/', $string);
                            }
                            $flags = $filter_condition['fnmflag'];
                            $flags |= $filter_condition['casefold'] ? FNM_CASEFOLD : 0;
                            $flags &= ~((strpos($pattern, '**') !== false) ? FNM_PATHNAME : 0);
                            return fnmatch($pattern, $string, $flags);
                        };
                    }
                }
                $filter_condition[$key] = $callback;
            }
        }

        return function ($file) use ($filter_condition) {
            if (!$file instanceof \SplFileInfo) {
                $file = new \SplFileInfo($file);
            }

            if (isset($filter_condition['dotfile']) && !$filter_condition['dotfile'] === (strpos($file->getFilename(), '.') === 0)) {
                return false;
            }

            foreach (['type' => false, '!type' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getType()))) {
                    return false;
                }
            }
            foreach (['perms' => false, '!perms' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === !!($filter_condition[$key] & $file->getPerms()))) {
                    return false;
                }
            }
            foreach (['mtime' => false, '!mtime' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getMTime()))) {
                    return false;
                }
            }
            foreach (['size' => false, '!size' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getSize()))) {
                    return false;
                }
            }
            foreach (['path' => false, '!path' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getPathname())) {
                    return false;
                }
            }
            foreach (['subpath' => false, '!subpath' => true] as $key => $cond) {
                $subpath = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPathname() : $file->getPathname();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($subpath)) {
                    return false;
                }
            }
            foreach (['dir' => false, '!dir' => true] as $key => $cond) {
                $dirname = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPath() : $file->getPath();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($dirname)) {
                    return false;
                }
            }
            foreach (['name' => false, '!name' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getFilename())) {
                    return false;
                }
            }
            foreach (['basename' => false, '!basename' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getBasename(concat('.', $file->getExtension())))) {
                    return false;
                }
            }
            foreach (['extension' => false, '!extension' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getExtension())) {
                    return false;
                }
            }
            foreach (['filter' => false, '!filter' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === !!$filter_condition[$key]($file)) {
                    return false;
                }
            }
            foreach (['contains' => false, '!contains' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === (file_pos($file->getPathname(), $filter_condition[$key]) !== false))) {
                    return false;
                }
            }

            return true;
        };
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\file_pos') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\file_pos'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\file_pos')) {
    /**
     * 範囲指定でファイルを読んで位置を返す
     *
     * $needle に配列を与えると OR 的動作で一つでも見つかった時点の位置を返す。
     * このとき「どれが見つかったか？」は得られない（場合によっては不便なので将来の改修対象）。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath = sys_get_temp_dir() . '/file_pos.txt';
     * file_put_contents($testpath, "hoge\nfuga\npiyo\nfuga");
     * // fuga の位置を返す
     * that(file_pos($testpath, 'fuga'))->is(5);
     * // 2つ目の fuga の位置を返す
     * that(file_pos($testpath, 'fuga', 6))->is(15);
     * // 見つからない場合は false を返す
     * that(file_pos($testpath, 'hogera'))->is(false);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename ファイル名
     * @param string|array $needle 探す文字列
     * @param int $start 読み込み位置
     * @param int|null $end 読み込むまでの位置。省略時は指定なし（最後まで）。負数は後ろからのインデックス
     * @param int|null $chunksize 読み込みチャンクサイズ。省略時は 4096 の倍数に正規化
     * @return int|false $needle の位置。見つからなかった場合は false
     */
    function file_pos($filename, $needle, $start = 0, $end = null, $chunksize = null)
    {
        if (!is_file($filename)) {
            throw new \InvalidArgumentException("'$filename' is not found.");
        }

        $needle = arrayval($needle, false);
        $maxlength = max(array_map('strlen', $needle));

        if ($start < 0) {
            $start += $filesize ?? $filesize = filesize($filename);
        }
        if ($end === null) {
            $end = $filesize ?? $filesize = filesize($filename);
        }
        if ($end < 0) {
            $end += $filesize ?? $filesize = filesize($filename);
        }
        if ($chunksize === null) {
            $chunksize = 4096 * ($maxlength % 4096 + 1);
        }

        assert(isset($filesize) || !isset($filesize));
        assert($chunksize >= $maxlength);

        $fp = fopen($filename, 'rb');
        try {
            fseek($fp, $start);
            while (!feof($fp)) {
                if ($start > $end) {
                    break;
                }
                $last = $part ?? '';
                $part = fread($fp, $chunksize);
                if (($p = strpos_array($part, $needle))) {
                    $min = min($p);
                    $result = $start + $min;
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                if (($p = strpos_array($last . $part, $needle))) {
                    $min = min($p);
                    $result = $start + $min - strlen($last);
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                $start += strlen($part);
            }
            return false;
        }
        finally {
            fclose($fp);
        }
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\file_set_contents') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\file_set_contents'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\file_set_contents')) {
    /**
     * ディレクトリも掘る file_put_contents
     *
     * 書き込みは一時ファイルと rename を使用してアトミックに行われる。
     *
     * Example:
     * ```php
     * file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
     * that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 書き込むファイル名
     * @param string $data 書き込む内容
     * @param int $umask ディレクトリを掘る際の umask
     * @return int 書き込まれたバイト数
     */
    function file_set_contents($filename, $data, $umask = 0002)
    {
        if (func_num_args() === 2) {
            $umask = umask();
        }

        $filename = path_normalize($filename);

        if (!is_dir($dirname = dirname($filename))) {
            if (!@mkdir_p($dirname, $umask)) {
                throw new \RuntimeException("failed to mkdir($dirname)");
            }
        }

        error_clear_last();
        $tempnam = @tempnam($dirname, 'tmp');
        if (strpos(error_get_last()['message'] ?? '', "file created in the system's temporary directory") !== false) {
            $result = file_put_contents($filename, $data);
            @chmod($filename, 0666 & ~$umask);
            return $result;
        }
        if (($result = file_put_contents($tempnam, $data)) !== false) {
            if (rename($tempnam, $filename)) {
                @chmod($filename, 0666 & ~$umask);
                return $result;
            }
            unlink($tempnam);
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\mkdir_p') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\mkdir_p'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\mkdir_p')) {
    /**
     * ディレクトリを再帰的に掘る
     *
     * 既に存在する場合は何もしない（エラーも出さない）。
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname ディレクトリ名
     * @param int $umask ディレクトリを掘る際の umask
     * @return bool 作成したら true
     */
    function mkdir_p($dirname, $umask = 0002)
    {
        if (func_num_args() === 1) {
            $umask = umask();
        }

        if (file_exists($dirname)) {
            return false;
        }

        return mkdir($dirname, 0777 & (~$umask), true);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\path_normalize') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\path_normalize'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\path_normalize')) {
    /**
     * パスを正規化する
     *
     * 具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。
     * realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_normalize('/path/to/something'))->isSame("{$DS}path{$DS}to{$DS}something");
     * that(path_normalize('/path/through/../something'))->isSame("{$DS}path{$DS}something");
     * that(path_normalize('./path/current/./through/../something'))->isSame("path{$DS}current{$DS}something");
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return string 正規化されたパス
     */
    function path_normalize($path)
    {
        $DS = DIRECTORY_SEPARATOR;

        // スキームの保護
        $with_scheme = false;
        $scheme = parse_url($path, PHP_URL_SCHEME);
        if (!($scheme === null || $scheme === 'file') && substr($path, strlen($scheme), 3) === '://') {
            $path = substr($path, strlen($scheme) + 3);
            $DS = '/';
            $with_scheme = true;
        }

        $delimiter = '/';
        if ($DS === '\\') {
            $delimiter .= '\\\\';
        }

        $result = [];
        foreach (preg_split("#[$delimiter]+#u", $path) as $part) {
            if ($part === '.') {
                continue;
            }
            if ($part === '..') {
                if (empty($result)) {
                    throw new \InvalidArgumentException("'$path' is invalid as path string.");
                }
                array_pop($result);
                continue;
            }
            $result[] = $part;
        }
        if (count($result) > 2 && $result[count($result) - 1] === '') {
            array_pop($result);
        }

        $path = implode($DS, $result);

        if ($with_scheme) {
            $path = "$scheme://$path";
        }

        return $path;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\rm_rf') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\rm_rf'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\rm_rf')) {
    /**
     * 中身があっても消せる rmdir
     *
     * Example:
     * ```php
     * mkdir(sys_get_temp_dir() . '/new/make/dir', 0777, true);
     * rm_rf(sys_get_temp_dir() . '/new');
     * that(file_exists(sys_get_temp_dir() . '/new'))->isSame(false);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname 削除するディレクトリ名。glob パターンが使える
     * @param bool $self 自分自身も含めるか。false を与えると中身だけを消す
     * @return bool 成功した場合に TRUE を、失敗した場合に FALSE を返します
     */
    function rm_rf($dirname, $self = true)
    {
        $main = static function ($dirname, $self) {
            if (!file_exists($dirname)) {
                return false;
            }

            $rdi = new \RecursiveDirectoryIterator($dirname, \FilesystemIterator::SKIP_DOTS);
            $rii = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);

            foreach ($rii as $it) {
                if ($it->isFile() || $it->isLink()) {
                    unlink($it->getPathname());
                }
                else {
                    rmdir($it->getPathname());
                }
            }

            return !$self || rmdir($dirname);
        };

        if (is_file($dirname) || is_link($dirname)) {
            return unlink($dirname);
        }
        // ↓で glob してるので、ディレクトリ判定しないとリモートファイルに対応できない
        if (is_dir($dirname)) {
            return $main($dirname, $self);
        }

        $result = true;
        $targets = glob($dirname, GLOB_BRACE | GLOB_NOCHECK | ($self ? 0 : GLOB_ONLYDIR));
        foreach ($targets as $target) {
            $result = $main($target, $self) && $result;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\delegate') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\delegate'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\delegate')) {
    /**
     * 指定 callable を指定クロージャで実行するクロージャを返す
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param \Closure $invoker クロージャを実行するためのクロージャ（実処理）
     * @param callable $callable 最終的に実行したいクロージャ
     * @param ?int $arity 引数の数
     * @return callable $callable を実行するクロージャ
     */
    function delegate($invoker, $callable, $arity = null)
    {
        $arity ??= parameter_length($callable, true, true);

        if (reflect_callable($callable)->isInternal()) {
            static $cache = [];
            $cache[(string) $arity] ??= evaluate('return new class()
            {
                private $invoker, $callable;

                public function spawn($invoker, $callable)
                {
                    $that = clone($this);
                    $that->invoker = $invoker;
                    $that->callable = $callable;
                    return $that;
                }

                public function __invoke(' . implode(',', is_infinite($arity)
                    ? ['...$_']
                    : array_map(fn($v) => '$_' . $v, array_keys(array_fill(1, $arity, null)))
                ) . ')
                {
                    return ($this->invoker)($this->callable, func_get_args());
                }
            };');
            return $cache[(string) $arity]->spawn($invoker, $callable);
        }

        switch (true) {
            case $arity === 0:
                return fn() => $invoker($callable, func_get_args());
            case $arity === 1:
                return fn($_1) => $invoker($callable, func_get_args());
            case $arity === 2:
                return fn($_1, $_2) => $invoker($callable, func_get_args());
            case $arity === 3:
                return fn($_1, $_2, $_3) => $invoker($callable, func_get_args());
            case $arity === 4:
                return fn($_1, $_2, $_3, $_4) => $invoker($callable, func_get_args());
            case $arity === 5:
                return fn($_1, $_2, $_3, $_4, $_5) => $invoker($callable, func_get_args());
            case is_infinite($arity):
                return fn(...$_) => $invoker($callable, func_get_args());
            default:
                $args = implode(',', array_map(fn($v) => '$_' . $v, array_keys(array_fill(1, $arity, null))));
                $stmt = 'return function (' . $args . ') use ($invoker, $callable) { return $invoker($callable, func_get_args()); };';
                return eval($stmt);
        }
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\func_user_func_array') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\func_user_func_array'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\func_user_func_array')) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable|null $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return fn($v) => $v;
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return delegate(function ($callback, $args) use ($plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        }, $callback, $plength);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\ansi_colorize') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\ansi_colorize'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\ansi_colorize')) {
    /**
     * 文字列に ANSI Color エスケープシーケンスを埋め込む
     *
     * - "blue" のような小文字色名は文字色
     * - "BLUE" のような大文字色名は背景色
     * - "bold" のようなスタイル名は装飾
     *
     * となる。その区切り文字は現在のところ厳密に定めていない（`fore+back|bold` のような形式で定めることも考えたけどメリットがない）。
     * つまり、アルファベット以外で分割するので、
     *
     * - `blue|WHITE@bold`: 文字青・背景白・太字
     * - `blue WHITE bold underscore`: 文字青・背景白・太字・下線
     * - `italic|bold,blue+WHITE  `: 文字青・背景白・太字・斜体
     *
     * という動作になる（記号で区切られていれば形式はどうでも良いということ）。
     * ただ、この指定方法は変更が入る可能性が高いのでスペースあたりで区切っておくのがもっとも無難。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param string $string 対象文字列
     * @param string $color 色とスタイル文字列
     * @return string エスケープシーケンス付きの文字列
     */
    function ansi_colorize($string, $color)
    {
        // see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters
        // see https://misc.flogisoft.com/bash/tip_colors_and_formatting
        $ansicodes = [
            // forecolor
            'default'    => [39, 39],
            'black'      => [30, 39],
            'red'        => [31, 39],
            'green'      => [32, 39],
            'yellow'     => [33, 39],
            'blue'       => [34, 39],
            'magenta'    => [35, 39],
            'cyan'       => [36, 39],
            'white'      => [97, 39],
            'gray'       => [90, 39],
            // backcolor
            'DEFAULT'    => [49, 49],
            'BLACK'      => [40, 49],
            'RED'        => [41, 49],
            'GREEN'      => [42, 49],
            'YELLOW'     => [43, 49],
            'BLUE'       => [44, 49],
            'MAGENTA'    => [45, 49],
            'CYAN'       => [46, 49],
            'WHITE'      => [47, 49],
            'GRAY'       => [100, 49],
            // style
            'bold'       => [1, 22],
            'faint'      => [2, 22], // not working ?
            'italic'     => [3, 23],
            'underscore' => [4, 24],
            'blink'      => [5, 25],
            'reverse'    => [7, 27],
            'conceal'    => [8, 28],
        ];

        $names = array_flip(preg_split('#[^a-z]#i', $color));
        $styles = array_intersect_key($ansicodes, $names);
        $setters = implode(';', array_column($styles, 0));
        $unsetters = implode(';', array_column($styles, 1));
        return "\033[{$setters}m{$string}\033[{$unsetters}m";
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\ansi_strip') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\ansi_strip'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\ansi_strip')) {
    /**
     * ANSI エスケープ文字を取り除く
     *
     * Example:
     * ```php
     * $ansi_string = ansi_colorize('hoge', 'bold red');
     * // エスケープ文字も含めて 19 文字
     * that(strlen($ansi_string))->isSame(19);
     * // ansi_strip すると本来の hoge がえられる
     * that(ansi_strip($ansi_string))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param string $string 対象文字列
     * @return string ANSI エスケープ文字が取り除かれた文字
     */
    function ansi_strip($string)
    {
        return preg_replace('#\\e\\[.+?(;.+?)*(?<!;)[a-z]#ui', '', $string);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\get_uploaded_files') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\get_uploaded_files'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\get_uploaded_files')) {
    /**
     * $_FILES の構造を組み替えて $_POST などと同じにする
     *
     * $_FILES の配列構造はバグとしか思えないのでそれを是正する関数。
     * 第1引数 $files は指定可能だが、大抵は $_FILES であり、指定するのはテスト用。
     *
     * サンプルを書くと長くなるので例は{@source \ryunosuke\Test\Package\UtilityTest::test_get_uploaded_files() テストファイル}を参照。
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param ?array $files $_FILES の同じ構造の配列。省略時は $_FILES
     * @return array $_FILES を $_POST などと同じ構造にした配列
     */
    function get_uploaded_files($files = null)
    {
        $result = [];
        foreach (($files ?: $_FILES) as $name => $file) {
            if (is_array($file['name'])) {
                $file = get_uploaded_files(array_each($file['name'], function (&$carry, $dummy, $subkey) use ($file) {
                    $carry[$subkey] = array_lookup($file, $subkey);
                }, []));
            }
            $result[$name] = $file;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\is_ansi') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\is_ansi'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\is_ansi')) {
    /**
     * リソースが ansi color に対応しているか返す
     *
     * パイプしたりリダイレクトしていると false を返す。
     *
     * @package ryunosuke\Functions\Package\info
     * @see https://github.com/symfony/console/blob/v4.2.8/Output/StreamOutput.php#L98
     *
     * @param resource $stream 調べるリソース
     * @return bool ansi color に対応しているなら true
     */
    function is_ansi($stream)
    {
        // テスト用に隠し引数で DS を取っておく
        $DIRECTORY_SEPARATOR = DIRECTORY_SEPARATOR;
        assert(!!$DIRECTORY_SEPARATOR = func_num_args() > 1 ? func_get_arg(1) : $DIRECTORY_SEPARATOR);

        if ('Hyper' === getenv('TERM_PROGRAM')) {
            return true;
        }

        if ($DIRECTORY_SEPARATOR === '\\') {
            return (\function_exists('sapi_windows_vt100_support') && @sapi_windows_vt100_support($stream))
                || false !== getenv('ANSICON')
                || 'ON' === getenv('ConEmuANSI')
                || 'xterm' === getenv('TERM');
        }

        return @stream_isatty($stream);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\evaluate') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\evaluate'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\evaluate')) {
    /**
     * eval のプロキシ関数
     *
     * 一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。
     * また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。
     *
     * 関数化してる以上 eval におけるコンテキストの引き継ぎはできない。
     * ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ（$this はどうしようもない）。
     *
     * 短いステートメントだと opcode が少ないのでファイルを経由せず直接 eval したほうが速いことに留意。
     * 一応引数で指定できるようにはしてある。
     *
     * Example:
     * ```php
     * $a = 1;
     * $b = 2;
     * $phpcode = ';
     * $c = $a + $b;
     * return $c * 3;
     * ';
     * that(evaluate($phpcode, get_defined_vars()))->isSame(9);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode 実行する php コード
     * @param array $contextvars コンテキスト変数配列
     * @param int $cachesize キャッシュするサイズ
     * @return mixed eval の return 値
     */
    function evaluate($phpcode, $contextvars = [], $cachesize = 256)
    {
        $cachefile = null;
        if ($cachesize && strlen($phpcode) >= $cachesize) {
            $cachefile = function_configure('cachedir') . '/' . rawurlencode(__FUNCTION__) . '-' . sha1($phpcode) . '.php';
            if (!file_exists($cachefile)) {
                file_put_contents($cachefile, "<?php $phpcode", LOCK_EX);
            }
        }

        try {
            if ($cachefile) {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return require func_get_arg(0);
                })($cachefile, $contextvars);
            }
            else {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return eval(func_get_arg(0));
                })($phpcode, $contextvars);
            }
        }
        catch (\ParseError $ex) {
            $errline = $ex->getLine();
            $errline_1 = $errline - 1;
            $codes = preg_split('#\\R#u', $phpcode);
            $codes[$errline_1] = '>>> ' . $codes[$errline_1];

            $N = 5; // 前後の行数
            $message = $ex->getMessage();
            $message .= "\n" . implode("\n", array_slice($codes, max(0, $errline_1 - $N), $N * 2 + 1));
            if ($cachefile) {
                $message .= "\n in " . realpath($cachefile) . " on line " . $errline . "\n";
            }
            throw new \ParseError($message, $ex->getCode(), $ex);
        }
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\parse_php') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\parse_php'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\parse_php')) {
    /**
     * php のコード断片をパースする
     *
     * 結果配列は token_get_all したものだが、「字句の場合に文字列で返す」仕様は適用されずすべて配列で返す。
     * つまり必ず `[TOKENID, TOKEN, LINE, POS]` で返す。
     *
     * @todo 現在の仕様では php タグが自動で付与されるが、標準と異なり直感的ではないのでその仕様は除去する
     * @todo そもそも何がしたいのかよくわからない関数になってきたので動作の洗い出しが必要
     *
     * Example:
     * ```php
     * $phpcode = 'namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * // namespace ～ ; を取得
     * $part = parse_php($phpcode, [
     *     'begin' => T_NAMESPACE,
     *     'end'   => ';',
     * ]);
     * that(implode('', array_column($part, 1)))->isSame('namespace Hogera;');
     *
     * // class ～ { を取得
     * $part = parse_php($phpcode, [
     *     'begin' => T_CLASS,
     *     'end'   => '{',
     * ]);
     * that(implode('', array_column($part, 1)))->isSame("class Example\n{");
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode パースする php コード
     * @param array|int $option パースオプション
     * @return array トークン配列
     */
    function parse_php($phpcode, $option = [])
    {
        if (is_int($option)) {
            $option = ['flags' => $option];
        }

        $default = [
            'phptag'         => true, // 初めに php タグを付けるか
            'short_open_tag' => null, // ショートオープンタグを扱うか（null だと余計なことはせず ini に従う）
            'line'           => [],   // 行の範囲（以上以下）
            'position'       => [],   // 文字位置の範囲（以上以下）
            'begin'          => [],   // 開始トークン
            'end'            => [],   // 終了トークン
            'offset'         => 0,    // 開始トークン位置
            'flags'          => 0,    // token_get_all の $flags. TOKEN_PARSE を与えると ParseError が出ることがあるのでデフォルト 0
            'cache'          => true, // キャッシュするか否か
            'greedy'         => false,// end と nest か一致したときに処理を継続するか
            'nest_token'     => [
                ')' => '(',
                '}' => '{',
                ']' => '[',
            ],
        ];
        $option += $default;

        $cachekey = var_hash($phpcode) . $option['flags'] . '-' . $option['phptag'] . '-' . var_export($option['short_open_tag'], true);
        static $cache = [];
        if (!($option['cache'] && isset($cache[$cachekey]))) {
            $phptag = $option['phptag'] ? '<?php ' : '';
            $phpcode = $phptag . $phpcode;
            $position = -strlen($phptag);

            $tokens = [];
            $tmp = token_get_all($phpcode, $option['flags']);
            for ($i = 0; $i < count($tmp); $i++) {
                $token = $tmp[$i];

                // token_get_all の結果は微妙に扱いづらいので少し調整する（string/array だったり、名前変換の必要があったり）
                if (!is_array($token)) {
                    $last = $tokens[count($tokens) - 1] ?? [null, 1, 0];
                    $token = [ord($token), $token, $last[2] + preg_match_all('/(?:\r\n|\r|\n)/', $last[1])];
                }

                // @codeCoverageIgnoreStart
                if ($option['short_open_tag'] === true && $token[0] === T_INLINE_HTML && ($p = strpos($token[1], '<?')) !== false) {
                    $newtokens = [];
                    $nlcount = 0;

                    if ($p !== 0) {
                        $html = substr($token[1], 0, $p);
                        $nlcount = preg_match_all('#\r\n|\r|\n#u', $html);
                        $newtokens[] = [T_INLINE_HTML, $html, $token[2]];
                    }

                    $code = substr($token[1], $p + 2);
                    $subtokens = token_get_all("<?php $code");
                    $subtokens[0][1] = '<?';
                    foreach ($subtokens as $subtoken) {
                        if (is_array($subtoken)) {
                            $subtoken[2] += $token[2] + $nlcount - 1;
                        }
                        $newtokens[] = $subtoken;
                    }

                    array_splice($tmp, $i + 1, 0, $newtokens);
                    continue;
                }
                if ($option['short_open_tag'] === false && $token[0] === T_OPEN_TAG && $token[1] === '<?') {
                    for ($j = $i + 1; $j < count($tmp); $j++) {
                        if ($tmp[$j][0] === T_CLOSE_TAG) {
                            break;
                        }
                    }
                    $html = implode('', array_map(fn($token) => is_array($token) ? $token[1] : $token, array_slice($tmp, $i, $j - $i + 1)));
                    array_splice($tmp, $i + 1, $j - $i, [[T_INLINE_HTML, $html, $token[2]]]);
                    continue;
                }
                // @codeCoverageIgnoreEnd

                $token[] = $position;
                if ($option['flags'] & TOKEN_NAME) {
                    $token[] = token_name($token[0]);
                }

                $position += strlen($token[1]);
                $tokens[] = $token;
            }
            // @codeCoverageIgnoreStart
            if ($option['short_open_tag'] === false) {
                for ($i = 0; $i < count($tokens); $i++) {
                    if ($tokens[$i][0] === T_INLINE_HTML && isset($tokens[$i + 1]) && $tokens[$i + 1][0] === T_INLINE_HTML) {
                        $tokens[$i][1] .= $tokens[$i + 1][1];
                        array_splice($tokens, $i + 1, 1, []);
                        $i--;
                    }
                }
            }
            // @codeCoverageIgnoreEnd
            $cache[$cachekey] = $tokens;
        }
        $tokens = $cache[$cachekey];

        $lines = $option['line'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $positions = $option['position'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $begin_tokens = (array) $option['begin'];
        $end_tokens = (array) $option['end'];
        $nest_tokens = $option['nest_token'];
        $greedy = $option['greedy'];

        $result = [];
        $starting = !$begin_tokens;
        $nesting = 0;
        $offset = is_array($option['offset']) ? ($option['offset'][0] ?? 0) : $option['offset'];
        $endset = is_array($option['offset']) ? ($option['offset'][1] ?? count($tokens)) : count($tokens);

        for ($i = $offset; $i < $endset; $i++) {
            $token = $tokens[$i];

            if ($lines[0] > $token[2]) {
                continue;
            }
            if ($lines[1] < $token[2]) {
                continue;
            }
            if ($positions[0] > $token[3]) {
                continue;
            }
            if ($positions[1] < $token[3]) {
                continue;
            }

            foreach ($begin_tokens as $t) {
                if ($t === $token[0] || $t === $token[1]) {
                    $starting = true;
                    break;
                }
            }
            if (!$starting) {
                continue;
            }

            $result[$i] = $token;

            foreach ($nest_tokens as $end_nest => $start_nest) {
                if ($token[0] === $start_nest || $token[1] === $start_nest) {
                    $nesting++;
                }
                if ($token[0] === $end_nest || $token[1] === $end_nest) {
                    $nesting--;
                }
            }

            foreach ($end_tokens as $t) {
                if ($t === $token[0] || $t === $token[1]) {
                    if ($nesting <= 0 || ($nesting === 1 && in_array($t, $nest_tokens, true))) {
                        if ($nesting === 0 && $greedy && isset($nest_tokens[$t])) {
                            break;
                        }
                        break 2;
                    }
                    break;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\preg_replaces') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\preg_replaces'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\preg_replaces')) {
    /**
     * パターン番号を指定して preg_replace する
     *
     * パターン番号を指定してそれのみを置換する。
     * 名前付きキャプチャを使用している場合はキーに文字列も使える。
     * 値にクロージャを渡した場合はコールバックされて置換される。
     *
     * $replacements に単一文字列を渡した場合、 `[1 => $replacements]` と等しくなる（第1キャプチャを置換）。
     *
     * Example:
     * ```php
     * // a と z に囲まれた数字を XXX に置換する
     * that(preg_replaces('#a(\d+)z#', [1 => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // 名前付きキャプチャも指定できる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // クロージャを渡すと元文字列を引数としてコールバックされる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => fn($src) => $src * 2], 'a123z'))->isSame('a246z');
     * // 複合的なサンプル（a タグの href と target 属性を書き換える）
     * that(preg_replaces('#<a\s+href="(?<href>.*)"\s+target="(?<target>.*)">#', [
     *     'href'   => fn($href) => strtoupper($href),
     *     'target' => fn($target) => strtoupper($target),
     * ], '<a href="hoge" target="fuga">inner text</a>'))->isSame('<a href="HOGE" target="FUGA">inner text</a>');
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param array|string|callable $replacements 置換文字列
     * @param string $subject 対象文字列
     * @param int $limit 置換回数
     * @param null $count 置換回数格納変数
     * @return string 置換された文字列
     */
    function preg_replaces($pattern, $replacements, $subject, $limit = -1, &$count = null)
    {
        $offset = 0;
        $count = 0;
        if (!is_arrayable($replacements)) {
            $replacements = [1 => $replacements];
        }

        preg_match_all($pattern, $subject, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER);
        foreach ($matches as $match) {
            if ($limit-- === 0) {
                break;
            }
            $count++;

            foreach ($match as $index => $m) {
                if ($m[1] >= 0 && $index !== 0 && isset($replacements[$index])) {
                    $src = $m[0];
                    $dst = $replacements[$index];
                    if ($dst instanceof \Closure) {
                        $dst = $dst($src);
                    }

                    $srclen = strlen($src);
                    $dstlen = strlen($dst);

                    $subject = substr_replace($subject, $dst, $offset + $m[1], $srclen);
                    $offset += $dstlen - $srclen;
                }
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\unique_string') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\unique_string'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\unique_string')) {
    /**
     * 文字列に含まれない文字列を生成する
     *
     * 例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。
     * 実装は愚直に文字列を調べて存在しなければそれを返すようになっている。
     * 一応初期値や文字セットは指定可能。
     *
     * $initial に int を与えると初期値としてその文字数分 $charlist から確保する。
     * 例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。
     * $initial に string を与えるとそれがそのまま初期値として使用される。
     * 例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。
     *
     * Example:
     * ```php
     * // 単純に呼ぶと生成1,2文字程度の文字列になる
     * that(unique_string('hello, world'))->stringLengthEqualsAny([1, 2]);
     * // 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
     * that(unique_string('hello, world', null, range(0, 9)))->stringLengthEquals(1);
     * // int を渡すと最低でもそれ以上は保証される
     * that(unique_string('hello, world', 5))->stringLengthEqualsAny([5, 6]);
     * // string を渡すとそれが初期値となる
     * that(unique_string('hello, world', 'prefix-'))->stringStartsWith('prefix');
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param string $source 元文字列
     * @param string|int $initial 初期文字列あるいは文字数
     * @param string|array $charlist 使用する文字セット
     * @return string 一意な文字列
     */
    function unique_string($source, $initial = null, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        assert(is_stringable($initial) || is_int($initial) || is_null($initial));

        if (is_stringable($charlist)) {
            $charlist = preg_split('//', $charlist, -1, PREG_SPLIT_NO_EMPTY);
        }

        $charlength = count($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $result = '';
        if (is_int($initial)) {
            shuffle($charlist);
            $result = implode('', array_slice($charlist, 0, $initial));
        }
        elseif (is_stringable($initial)) {
            $result = $initial;
        }

        $p = 0;
        do {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        } while (($p = strpos($source, $result, $p)) !== false);

        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\callable_code') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\callable_code'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\callable_code')) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function (...$args) {return true;});
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function (...$args) {return true;}));
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $meta = parse_php("<?php $codeblock", [
            'begin' => [T_FN, T_FUNCTION],
            'end'   => ['{', T_DOUBLE_ARROW],
        ]);
        $end = array_pop($meta);

        if ($end[0] === T_DOUBLE_ARROW) {
            $body = parse_php("<?php $codeblock", [
                'begin'  => T_DOUBLE_ARROW,
                'end'    => [';', ',', ')'],
                'offset' => last_key($meta),
                'greedy' => true,
            ]);
            $body = array_slice($body, 1, -1);
        }
        else {
            $body = parse_php("<?php $codeblock", [
                'begin'  => '{',
                'end'    => '}',
                'offset' => last_key($meta),
            ]);
        }

        return [trim(implode('', array_column($meta, 1))), trim(implode('', array_column($body, 1)))];
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\function_parameter') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\function_parameter'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\function_parameter')) {
    /**
     * 関数/メソッドの引数定義を取得する
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param \ReflectionFunctionAbstract|callable $eitherReffuncOrCallable 関数/メソッドリフレクション or callable
     * @return array [引数名 => 引数宣言] の配列
     */
    function function_parameter($eitherReffuncOrCallable)
    {
        $reffunc = $eitherReffuncOrCallable instanceof \ReflectionFunctionAbstract
            ? $eitherReffuncOrCallable
            : reflect_callable($eitherReffuncOrCallable);

        $result = [];
        foreach ($reffunc->getParameters() as $parameter) {
            $declare = '';

            if ($parameter->hasType()) {
                $declare .= reflect_types($parameter->getType())->getName() . ' ';
            }

            if ($parameter->isPassedByReference()) {
                $declare .= '&';
            }

            if ($parameter->isVariadic()) {
                $declare .= '...';
            }

            $declare .= '$' . $parameter->getName();

            if ($parameter->isOptional()) {
                $defval = null;

                // 組み込み関数のデフォルト値を取得することは出来ない（isDefaultValueAvailable も false を返す）
                if ($parameter->isDefaultValueAvailable()) {
                    // 修飾なしでデフォルト定数が使われているとその名前空間で解決してしまうので場合分けが必要
                    if ($parameter->isDefaultValueConstant() && strpos($parameter->getDefaultValueConstantName(), '\\') === false) {
                        $defval = $parameter->getDefaultValueConstantName();
                    }
                    else {
                        $default = $parameter->getDefaultValue();
                        $defval = var_export2($default, true);
                        if (is_string($default)) {
                            $defval = strtr($defval, [
                                "\r" => "\\r",
                                "\n" => "\\n",
                                "\t" => "\\t",
                                "\f" => "\\f",
                                "\v" => "\\v",
                            ]);
                        }
                    }
                }
                // 「オプショナルだけどデフォルト値がないって有り得るのか？」と思ったが、上記の通り組み込み関数だと普通に有り得るようだ
                // notice が出るので記述せざるを得ないがその値を得る術がない。が、どうせ与えられないので null でいい
                elseif (version_compare(PHP_VERSION, 8.0) < 0) {
                    $defval = 'null';
                }

                if (isset($defval)) {
                    $declare .= ' = ' . $defval;
                }
            }

            $name = ($parameter->isPassedByReference() ? '&' : '') . '$' . $parameter->getName();
            $result[$name] = $declare;
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\parameter_length') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\parameter_length'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\parameter_length')) {
    /**
     * callable の引数の数を返す
     *
     * クロージャはキャッシュされない。毎回リフレクションを生成し、引数の数を調べてそれを返す。
     * （クロージャには一意性がないので key-value なキャッシュが適用できない）。
     * ので、ループ内で使ったりすると目に見えてパフォーマンスが低下するので注意。
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        // クロージャの $call_name には一意性がないのでキャッシュできない（spl_object_hash でもいいが、かなり重複するので完全ではない）
        if ($callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            if ($thought_variadic && $ref->isVariadic()) {
                return INF;
            }
            elseif ($require_only) {
                return $ref->getNumberOfRequiredParameters();
            }
            else {
                return $ref->getNumberOfParameters();
            }
        }

        // $call_name 取得
        is_callable($callable, false, $call_name);

        $cache = cache($call_name, function () use ($callable) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            return [
                '00' => $ref->getNumberOfParameters(),
                '01' => $ref->isVariadic() ? INF : $ref->getNumberOfParameters(),
                '10' => $ref->getNumberOfRequiredParameters(),
                '11' => $ref->isVariadic() ? INF : $ref->getNumberOfRequiredParameters(),
            ];
        }, __FUNCTION__);
        return $cache[(int) $require_only . (int) $thought_variadic];
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\reflect_callable') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\reflect_callable'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\reflect_callable')) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @return \ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if ($callable instanceof \Closure || strpos($call_name, '::') === false) {
            return new \ReflectionFunction($callable);
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                return (new \ReflectionClass($class))->getParentClass()->getMethod($method);
            }
            return new \ReflectionMethod($class, $method);
        }
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\reflect_types') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\reflect_types'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\reflect_types')) {
    /**
     * ReflectionType の型配列を返す
     *
     * ReflectionType のインターフェース・仕様がコロコロ変わってついていけないので関数化した。
     *
     * ReflectionType に準ずるインスタンスを渡すと取り得る候補を配列ライクなオブジェクトで返す。
     * 引数は配列で複数与えても良い。よしなに扱って複数型として返す。
     * また「Type が一意に導出できる Reflection」を渡しても良い（ReflectionProperty など）。
     * null を与えた場合はエラーにはならず、スルーされる（getType は null を返し得るので利便性のため）。
     *
     * 単純に ReflectionType の配列ライクなオブジェクトを返すが、そのオブジェクトは `__toString` が実装されており、文字列化するとパイプ区切りの型文字列を返す。
     * これは 8.0 における ReflectionUnionType の `__toString` を模倣したものである。
     * 互換性のある型があった場合、上位の型に内包されて型文字列としては出現しない。
     *
     * Countable も実装されているが、その結果は「内部 Type の数」ではなく、論理的に「取り得る型の数」を返す。
     * 例えば `?int` は型としては1つだが、実際は int, null の2つを取り得るため、 count は 2 を返す。
     * 端的に言えば「`__toString` のパイプ区切りの型の数」を返す。
     *
     * あとは便利メソッドとして下記が生えている。
     *
     * - jsonSerialize: JsonSerializable 実装
     * - getTypes: 取り得る型をすべて返す（ReflectionUnionType 互換）
     * - getName: ReflectionUnionType 非互換 toString な型宣言文字列を返す
     * - allows: その値を取りうるか判定して返す
     *
     * ReflectionUnionType とは完全互換ではないので、php8.0が完全に使える環境であれば素直に ReflectionUnionType を使ったほうが良い。
     * （「常に（型分岐せずに）複数形で扱える」程度のメリットしかない。allows は惜しいが）。
     *
     * ちなみに型の変遷は下記の通り。
     *
     * - php7.1: ReflectionType::__toString が非推奨になった
     * - php7.1: ReflectionNamedType が追加され、各種 getType でそれを返すようになった
     * - php8.0: ReflectionType::__toString が非推奨ではなくなった
     * - php8.0: ReflectionUnionType が追加され、複合の場合は getType でそれを返すようになった
     *
     * Example:
     * ```php
     * $object = new class {
     *     function method(object $o):?string {}
     * };
     * $method = new \ReflectionMethod($object, 'method');
     * $types = reflect_types($method->getParameters()[0]->getType());
     * // 文字列化すると型宣言文字列を返すし、配列アクセスや count, iterable でそれぞれの型が得られる
     * that((string) $types)->is('object');
     * that($types[0])->isInstanceOf(\ReflectionType::class);
     * that(iterator_to_array($types))->eachIsInstanceOf(\ReflectionType::class);
     * that(count($types))->is(1);
     * // 返り値でも同じ（null 許容なので null が付くし count も 2 になる）
     * $types = reflect_types($method->getReturnType());
     * that((string) $types)->is('string|null');
     * that(count($types))->is(2);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param \ReflectionFunctionAbstract|\ReflectionType|\ReflectionType[]|null $reflection_type getType 等で得られるインスタンス
     * @return \ReflectionAnyType|object
     */
    function reflect_types($reflection_type = null)
    {
        if (!is_array($reflection_type)) {
            $reflection_type = [$reflection_type];
        }

        foreach ($reflection_type as $n => $rtype) {
            if ($rtype instanceof \ReflectionProperty) {
                $reflection_type[$n] = $rtype->getType();
            }
            if ($rtype instanceof \ReflectionFunctionAbstract) {
                $reflection_type[$n] = $rtype->getReturnType();
            }
            if ($rtype instanceof \ReflectionParameter) {
                $reflection_type[$n] = $rtype->getType();
            }
        }

        return new class(...$reflection_type)
            extends \stdClass
            implements \IteratorAggregate, \ArrayAccess, \Countable, \JsonSerializable {

            private const PSEUDO = [
                'mixed'    => [],
                'static'   => ['object', 'mixed'],
                'self'     => ['static', 'object', 'mixed'],
                'parent'   => ['static', 'object', 'mixed'],
                'callable' => ['mixed'],
                'iterable' => ['mixed'],
                'object'   => ['mixed'],
                'array'    => ['iterable', 'mixed'],
                'string'   => ['mixed'],
                'int'      => ['mixed'],
                'float'    => ['mixed'],
                'bool'     => ['mixed'],
                'false'    => ['bool', 'mixed'],
                'null'     => ['mixed'],
                'void'     => [],
            ];

            public function __construct(?\ReflectionType ...$reflection_types)
            {
                $types = [];
                foreach ($reflection_types as $type) {
                    if ($type === null) {
                        continue;
                    }

                    /** @noinspection PhpElementIsNotAvailableInCurrentPhpVersionInspection */
                    $types = array_merge($types, $type instanceof \ReflectionUnionType ? $type->getTypes() : [$type]);
                }

                // 配列キャストで配列を得たいので下手にフィールドを宣言せず直に生やす
                foreach ($types as $n => $type) {
                    $this->$n = $type;
                }
            }

            public function __toString()
            {
                return implode('|', $this->toStrings(true, true));
            }

            public function getIterator(): \Traversable
            {
                // yield from $this->getTypes();
                return new \ArrayIterator($this->getTypes());
            }

            public function offsetExists($offset): bool
            {
                return isset($this->$offset);
            }

            /** @noinspection PhpLanguageLevelInspection */
            #[\ReturnTypeWillChange]
            public function offsetGet($offset)
            {
                return $this->$offset;
            }

            public function offsetSet($offset, $value): void
            {
                // for debug
                if (is_string($value)) {
                    $value = new class ($value, self::PSEUDO) extends \ReflectionNamedType {
                        private $typename;
                        private $nullable;
                        private $builtins;

                        public function __construct($typename, $builtins)
                        {
                            $this->typename = ltrim($typename, '?');
                            $this->nullable = $typename[0] === '?';
                            $this->builtins = $builtins;
                        }

                        public function getName(): string { return $this->typename; }

                        public function allowsNull(): bool { return $this->nullable; }

                        public function isBuiltin(): bool { return isset($this->builtins[$this->typename]); }

                        public function __toString(): string { return $this->getName(); }
                    };
                }

                assert($value instanceof \ReflectionType);
                if ($offset === null) {
                    $offset = max(array_keys($this->getTypes()) ?: [-1]) + 1;
                }
                $this->$offset = $value;
            }

            public function offsetUnset($offset): void
            {
                unset($this->$offset);
            }

            public function count(): int
            {
                return count($this->toStrings(true, false));
            }

            public function jsonSerialize(): array
            {
                return $this->toStrings(true, true);
            }

            public function getName()
            {
                $types = array_flip($this->toStrings(true, true));
                $nullable = false;
                if (isset($types['null']) && count($types) === 2) {
                    unset($types['null']);
                    $nullable = true;
                }

                $result = [];
                foreach ($types as $type => $dummy) {
                    $result[] = (isset(self::PSEUDO[$type]) ? '' : '\\') . $type;
                }
                return ($nullable ? '?' : '') . implode('|', $result);
            }

            public function getTypes()
            {
                return (array) $this;
            }

            public function allows($type, $strict = false)
            {
                $types = array_flip($this->toStrings(false, false));

                if (isset($types['mixed'])) {
                    return true;
                }

                foreach ($types as $allow => $dummy) {
                    if (function_exists($f = "is_$allow") && $f($type)) {
                        return true;
                    }
                    if (is_a($type, $allow, true)) {
                        return true;
                    }
                }

                if (!$strict) {
                    if (is_int($type) || is_float($type) || is_bool($type)) {
                        if (isset($types['int']) || isset($types['float']) || isset($types['bool']) || isset($types['string'])) {
                            return true;
                        }
                    }
                    if (is_string($type) || (is_object($type) && method_exists($type, '__toString'))) {
                        if (isset($types['string'])) {
                            return true;
                        }
                        if ((isset($types['int']) || isset($types['float'])) && is_numeric("$type")) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private function toStrings($ignore_compatible = true, $sort = true)
            {
                $types = [];
                foreach ($this->getTypes() as $type) {
                    // ドキュメント上は「ReflectionNamedType を返す可能性があります」とのことなので getName 前提はダメ
                    // かといって文字列化前提だと 7.1 以降で deprecated が出てしまう
                    // つまり愚直に分岐するか @ で抑制するくらいしか多バージョン対応する術がない（7.1 の deprecated を解除して欲しい…）
                    $types[$type instanceof \ReflectionNamedType ? $type->getName() : (string) $type] = true;

                    if ($type->allowsNull()) {
                        $types['null'] = true;
                    }
                }

                if ($ignore_compatible) {
                    $types = array_filter($types, function ($type) use ($types) {
                        // いくつか互換のある内包疑似型が存在する（iterable は array を内包するし、 bool は false を内包する）
                        foreach (self::PSEUDO[$type] ?? [] as $parent) {
                            if (isset($types[$parent])) {
                                return false;
                            }
                        }
                        // さらに object 疑似型は全てのクラス名を内包する
                        if (isset($types['object']) && !isset(self::PSEUDO[$type])) {
                            return false;
                        }
                        return true;
                    }, ARRAY_FILTER_USE_KEY);
                }

                if ($sort) {
                    static $orders = null;
                    $orders ??= array_flip(array_keys(self::PSEUDO));
                    uksort($types, function ($a, $b) use ($orders) {
                        $issetA = isset($orders[$a]);
                        $issetB = isset($orders[$b]);
                        switch (true) {
                            case $issetA && $issetB:   // 共に疑似型
                                return $orders[$a] - $orders[$b];
                            case !$issetA && !$issetB: // 共にクラス名
                                return strcasecmp($a, $b);
                            case !$issetA && $issetB:  // A だけがクラス名
                                return -1;
                            case $issetA && !$issetB:  // B だけがクラス名
                                return +1;
                        }
                    });
                }
                return array_keys($types);
            }
        };
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\include_stream') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\include_stream'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\include_stream')) {
    /**
     * file スキームを上書きして include/require をフックできるストリームオブジェクトを返す
     *
     * register で include/require しようとしている $filename が渡ってくる callable を登録する。
     * restore で登録を解除する。
     *
     * stream wrapper にはスタッキングや取得系関数がないため、この関数を使うと file:// の登録は全て解除されるので注意。
     *
     * @package ryunosuke\Functions\Package\stream
     *
     * @return \IncludeStream|object stream wrapper オブジェクト
     */
    function include_stream()
    {
        static $declareProtocol;
        /**
         * file スキームで STREAM_OPEN_FOR_INCLUDE だけを特別扱いしたプロトコル
         *
         * include/require で呼ばれるメソッドはたかが知れているが、その前後等で通常操作がある可能性があるため、結局全部の実装が必要。
         */
        $declareProtocol ??= new class() {
            /** @var int https://github.com/php/php-src/blob/php-7.2.11/main/php_streams.h#L528-L529 */
            private const STREAM_OPEN_FOR_INCLUDE = 0x00000080;

            private static $hooks = [];

            private $handle;

            private $position;
            private $contents;
            private $stat;

            public $context;

            #<editor-fold desc="directory">

            public function dir_opendir($path, $options)
            {
                assert(isset($options)); // @todo It is used?
                return !!$this->handle = $this->call_original(fn() => opendir($path, ...$this->context ? [$this->context] : []));
            }

            public function dir_readdir()
            {
                return $this->call_original(fn() => readdir($this->handle));
            }

            public function dir_rewinddir()
            {
                return $this->call_original(fn() => rewinddir($this->handle));
            }

            public function dir_closedir()
            {
                return $this->call_original(fn() => closedir($this->handle));
            }

            #</editor-fold>

            #<editor-fold desc="stream">

            public function stream_open($path, $mode, $options, &$opened_path)
            {
                $use_path = $options & STREAM_USE_PATH;
                $report_errors = $options & STREAM_REPORT_ERRORS;
                $open_for_include = $options & self::STREAM_OPEN_FOR_INCLUDE;

                if ($open_for_include) {
                    if (!$this->call_original(function ($hook) use ($path) {
                        $contents = $hook($path) ?? @file_get_contents($path);
                        if (!is_string($contents)) {
                            return false;
                        }
                        $this->position = 0;
                        $this->contents = $contents;
                        $this->stat = stat($path);
                        $this->stat[7] = $this->stat['size'] = strlen($this->contents);
                        return true;
                    })) {
                        return false;
                    }
                    if ($use_path) {
                        $opened_path = stream_resolve_include_path($path); // @codeCoverageIgnore
                    }
                    return true;
                }

                $this->handle = $this->call_original(function ($hook) use ($path, $mode, $use_path, $report_errors) {
                    if ($report_errors) {
                        return fopen($path, $mode, $use_path, $this->context); // @codeCoverageIgnore
                    }
                    else {
                        return @fopen($path, $mode, $use_path, $this->context);
                    }
                });
                if ($use_path && $this->handle) {
                    $opened_path = stream_get_meta_data($this->handle)['uri']; // @codeCoverageIgnore
                }
                return !!$this->handle;
            }

            public function stream_lock($operation)
            {
                assert($this->handle, 'never call this method');
                // file_put_contents (LOCK_EX) を呼ぶと 0 で来ることがある
                if ($operation === 0) {
                    return true;
                }
                return flock($this->handle, $operation);
            }

            public function stream_tell()
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => ftell($this->handle));
            }

            public function stream_seek(int $offset, int $whence = SEEK_SET)
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => fseek($this->handle, $offset, $whence)) === 0;
            }

            public function stream_eof()
            {
                if (!$this->handle) {
                    return $this->position >= $this->stat['size'];
                }
                return feof($this->handle);
            }

            public function stream_read($count)
            {
                if (!$this->handle) {
                    $buffer = substr($this->contents, $this->position, $count);
                    $this->position += $count;
                    return $buffer;
                }
                return fread($this->handle, $count);
            }

            public function stream_write(string $data)
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => fwrite($this->handle, $data));
            }

            public function stream_truncate(int $new_size): bool
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => ftruncate($this->handle, $new_size));
            }

            public function stream_flush(): bool
            {
                assert($this->handle, 'never call this method');
                return $this->call_original(fn() => fflush($this->handle));
            }

            public function stream_close()
            {
                if (!$this->handle) {
                    return true;
                }
                return fclose($this->handle);
            }

            public function stream_stat()
            {
                if (!$this->handle) {
                    return $this->stat;
                }
                return fstat($this->handle);
            }

            public function stream_set_option($option, $arg1, $arg2)
            {
                if (!$this->handle) {
                    return true;
                }
                // Windows の file スキームでは呼ばれない？（確かにブロッキングやタイムアウトは無縁そう）
                // @codeCoverageIgnoreStart
                switch ($option) {
                    default:
                        throw new \Exception();
                    case STREAM_OPTION_BLOCKING:
                        return stream_set_blocking($this->handle, $arg1);
                    case STREAM_OPTION_READ_TIMEOUT:
                        return stream_set_timeout($this->handle, $arg1, $arg2);
                    case STREAM_OPTION_READ_BUFFER:
                        return stream_set_read_buffer($this->handle, $arg2) === 0; // @todo $arg1 is used?
                    case STREAM_OPTION_WRITE_BUFFER:
                        return stream_set_write_buffer($this->handle, $arg2) === 0; // @todo $arg1 is used?
                }
                // @codeCoverageIgnoreEnd
            }

            /**
             * @codeCoverageIgnore
             */
            public function stream_cast(int $cast_as)
            {
                assert(is_int($cast_as));
                assert($this->handle, 'never call this method');
                return $this->handle;
            }

            #</editor-fold>

            #<editor-fold desc="url">

            public function stream_metadata($path, $option, $value)
            {
                return $this->call_original(function () use ($path, $option, $value) {
                    switch ($option) {
                        default:
                            throw new \Exception(); // @codeCoverageIgnore
                        case STREAM_META_TOUCH:
                            return touch($path, ...$value);
                        case STREAM_META_ACCESS:
                            return chmod($path, $value);
                        case STREAM_META_OWNER_NAME:
                        case STREAM_META_OWNER:
                            return chown($path, $value);
                        case STREAM_META_GROUP_NAME:
                        case STREAM_META_GROUP:
                            return chgrp($path, $value);
                    }
                });
            }

            public function url_stat($path, $flags)
            {
                return $this->call_original(function () use ($path, $flags) {
                    if ($flags & STREAM_URL_STAT_LINK) {
                        $func = 'lstat';
                    }
                    else {
                        $func = 'stat';
                    }
                    if ($flags & STREAM_URL_STAT_QUIET) {
                        return @$func($path);
                    }
                    else {
                        return $func($path);
                    }
                });
            }

            public function mkdir(string $path, int $mode, int $options)
            {
                return $this->call_original(fn() => mkdir($path, $mode, !!($options & STREAM_MKDIR_RECURSIVE), $this->context));
            }

            public function rmdir(string $path, int $options)
            {
                assert(isset($options)); // @todo It is used?
                return $this->call_original(fn() => rmdir($path, $this->context));
            }

            public function rename(string $path_from, string $path_to)
            {
                return $this->call_original(fn() => rename($path_from, $path_to, $this->context));
            }

            public function unlink(string $path)
            {
                return $this->call_original(fn() => unlink($path, $this->context));
            }

            #</editor-fold>

            public function register($hook)
            {
                stream_wrapper_unregister('file');
                stream_wrapper_register('file', get_class($this));
                self::$hooks[] = $hook;
                return $this;
            }

            public function restore()
            {
                stream_wrapper_unregister('file');
                stream_wrapper_restore('file');
                return array_pop(self::$hooks);
            }

            private function call_original($function)
            {
                $current = $this->restore();
                try {
                    return $function($current);
                }
                finally {
                    $this->register($current);
                }
            }
        };

        return $declareProtocol;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\profiler') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\profiler'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\profiler')) {
    /**
     * 外部ツールに頼らない pure php なプロファイラを返す
     *
     * file プロトコル上書きと ticks と debug_backtrace によるかなり無理のある実装なので動かない環境・コードは多い。
     * その分お手軽だが下記の注意点がある。
     *
     * - file プロトコルを上書きするので、既に読み込み済みのファイルは計上されない
     * - tick されないステートメントは計上されない
     *     - 1行メソッドなどでありがち
     * - A->B->C という呼び出しで C が 3秒、B が 2秒、A が1秒かかった場合、 A は 6 秒、B は 5秒、C は 3 秒といて計上される
     *     - つまり、配下の呼び出しも重複して計上される
     *
     * この関数を呼んだ時点で計測は始まる。
     * 返り値としてイテレータを返すので、foreach で回せばコールスタック・回数・時間などが取得できる。
     * 配列で欲しい場合は直に呼べば良い。
     *
     * @package ryunosuke\Functions\Package\stream
     *
     * @param array $options オプション配列
     * @return \Traversable|callable プロファイライテレータ
     */
    function profiler($options = [])
    {
        $profiler = new class($options) implements \IteratorAggregate {
            private $result = [];
            private $wrapper;
            private $ticker;

            public function __construct($options = [])
            {
                $this->wrapper = include_stream()->register(static function ($filename) {
                    if (pathinfo($filename, PATHINFO_EXTENSION) === 'php') {
                        return "<?php declare(ticks=1) ?>" . file_get_contents($filename);
                    }
                });

                $options = array_replace([
                    'callee'   => null,
                    'location' => null,
                ], $options);
                $last_trace = [];
                $result = &$this->result;
                $this->ticker = static function () use ($options, &$last_trace, &$result) {
                    $now = microtime(true);
                    $traces = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);

                    $last_count = count($last_trace);
                    $current_count = count($traces);

                    // スタック数が変わってない（=同じメソッドを処理している？）
                    if ($current_count === $last_count) {
                        assert($current_count === $last_count); // @codeCoverageIgnore
                    }
                    // スタック数が増えた（=新しいメソッドが開始された？）
                    elseif ($current_count > $last_count) {
                        foreach (array_slice($traces, 1, $current_count - $last_count) as $last) {
                            $last['time'] = $now;
                            $last['callee'] = (isset($last['class'], $last['type']) ? $last['class'] . $last['type'] : '') . $last['function'];
                            $last['location'] = isset($last['file'], $last['line']) ? $last['file'] . '#' . $last['line'] : null;
                            array_unshift($last_trace, $last);
                        }
                    }
                    // スタック数が減った（=処理してたメソッドを抜けた？）
                    elseif ($current_count < $last_count) {
                        $prev = null; // array_map などの内部関数はスタックが一気に2つ増減する
                        foreach (array_splice($last_trace, 0, $last_count - $current_count) as $last) {
                            $time = $now - $last['time'];
                            $callee = $last['callee'];
                            $location = $last['location'] ?? ($prev['file'] ?? '') . '#' . ($prev['line'] ?? '');
                            $prev = $last;

                            foreach (['callee', 'location'] as $key) {
                                $condition = $options[$key];
                                $value = $$key;
                                if ($condition !== null) {
                                    if ($condition instanceof \Closure) {
                                        if (!$condition($value)) {
                                            continue 2;
                                        }
                                    }
                                    else {
                                        if (!preg_match($condition, $value)) {
                                            continue 2;
                                        }
                                    }
                                }
                            }
                            $result[$callee][$location][] = $time;
                        }
                    }
                };

                register_tick_function($this->ticker);
                opcache_reset();
            }

            public function __destruct()
            {
                unregister_tick_function($this->ticker);

                $this->wrapper->restore();
            }

            public function __invoke()
            {
                return $this->result;
            }

            public function getIterator(): \Traversable
            {
                return yield from $this->result;
            }
        };

        return $profiler;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\concat') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\concat'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\concat')) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる（あっちは NULL だが）。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param mixed ...$variadic 結合する文字列（可変引数）
     * @return string 結合した文字列
     */
    function concat(...$variadic)
    {
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s = (string) $s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\mb_monospace') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\mb_monospace'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\mb_monospace')) {
    /**
     * ASCII 文字を1, それ以外を2で計算した文字幅を返す
     *
     * mb_strwidth は記号も1で返すので若干使いづらい（仕様的にしょうがない）。
     * 日本語圏内であれば記号や絵文字も2バイト換算の方が便利なことが多いのでそのようにしたもの。
     *
     * オプションでコードポイント配列を渡すとそれに従って幅を加算する。
     * コードポイントの指定は Example を参照。
     *
     * Example:
     * ```php
     * that(mb_monospace("※★▼…"))->is(8);     // 記号類も2バイト換算で8
     * that(mb_monospace("123456７8８"))->is(11); // 比較用（フォントに依存するが）
     * that(mb_monospace("Σ(ﾟДﾟ)え!！"))->is(15); // 半角全角の判定ではなく ASCII 判定なので 15
     * that(mb_monospace("Σ(ﾟДﾟ)え!！", [         // コードポイントを指定すれば合わせることが可能
     *     "Σ"    => 1, // 単体指定（シグマ）
     *     "Ѐ-ӿ"  => 1, // 範囲指定（キリル文字）
     *     0xFF9F => 1, // 直指定（半角半濁点）
     * ]))->is(11);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $codepoints コードポイント配列
     * @return int 等幅の文字幅
     */
    function mb_monospace($string, $codepoints = [])
    {
        $widthmap = [];
        foreach ($codepoints as $codepoint => $width) {
            // 数値あるいは数値に準ずる値（intval がややこしくなるのでコードポイント 0 は考慮しない）
            if (is_int($codepoint) || intval($codepoint, 0) !== 0) {
                $widthmap[mb_chr(intval($codepoint, 0))] = $width;
            }
            // 文字列あるいは - による範囲指定
            else {
                // mb_ereg_search_regs が使いにくすぎるので callback で代用している
                $pairs = [];
                $codepoint = mb_ereg_replace_callback('([^-])\-([^-])', function ($m) use (&$pairs) {
                    $pairs[] = [mb_ord($m[1]), mb_ord($m[2])];
                    return '';
                }, $codepoint);
                foreach ($pairs as [$s, $e]) {
                    for ($i = $s; $i <= $e; $i++) {
                        $widthmap[mb_chr($i)] = $width;
                    }
                }
                foreach (mb_str_split($codepoint) as $char) {
                    $widthmap[$char] = $width;
                }
            }
        }

        $width = 0;
        foreach (mb_str_split($string) as $char) {
            if (isset($widthmap[$char])) {
                $width += $widthmap[$char];
            }
            elseif (strlen($char) === 1) {
                $width += 1;
            }
            else {
                $width += 2;
            }
        }
        return $width;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\mb_substr_replace') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\mb_substr_replace'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\mb_substr_replace')) {
    /**
     * マルチバイト対応 substr_replace
     *
     * 本家は配列を与えたりできるが、ややこしいし使う気がしないので未対応。
     *
     * Example:
     * ```php
     * // 2文字目から5文字を「あいうえお」に置換する
     * that(mb_substr_replace('０１２３４５６７８９', 'あいうえお', 2, 5))->isSame('０１あいうえお７８９');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $replacement 置換文字列
     * @param int $start 開始位置
     * @param ?int $length 置換長
     * @return string 置換した文字列
     */
    function mb_substr_replace($string, $replacement, $start, $length = null)
    {
        $string = (string) $string;

        $strlen = mb_strlen($string);
        if ($start < 0) {
            $start += $strlen;
        }
        if ($length === null) {
            $length = $strlen;
        }
        if ($length < 0) {
            $length += $strlen - $start;
        }

        return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\multiexplode') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\multiexplode'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\multiexplode')) {
    /**
     * explode の配列対応と $limit の挙動を変えたもの
     *
     * $delimiter には配列が使える。いわゆる「複数文字列での分割」の動作になる。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // 配列を与えると複数文字列での分割
     * that(multiexplode([',', ' ', '|'], 'a,b c|d'))->isSame(['a', 'b', 'c', 'd']);
     * // 負数を与えると前詰め
     * that(multiexplode(',', 'a,b,c,d', -2))->isSame(['a,b,c', 'd']);
     * // もちろん上記2つは共存できる
     * that(multiexplode([',', ' ', '|'], 'a,b c|d', -2))->isSame(['a,b c', 'd']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $delimiter 分割文字列。配列可
     * @param string $string 対象文字列
     * @param int $limit 分割数
     * @return array 分割された配列
     */
    function multiexplode($delimiter, $string, $limit = \PHP_INT_MAX)
    {
        $limit = (int) $limit;
        if ($limit < 0) {
            // 下手に php で小細工するよりこうやって富豪的にやるのが一番速かった
            return array_reverse(array_map('strrev', multiexplode($delimiter, strrev($string), -$limit)));
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }
        $delimiter = array_map(fn($v) => preg_quote($v, '#'), arrayize($delimiter));
        return preg_split('#' . implode('|', $delimiter) . '#', $string, $limit);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\str_ellipsis') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\str_ellipsis'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\str_ellipsis')) {
    /**
     * 文字列を指定数に丸める
     *
     * mb_strimwidth と似ているが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 8文字に丸める（$pos 省略なので真ん中が省略される）
     * that(str_ellipsis('1234567890', 8, '...'))->isSame('12...890');
     * // 8文字に丸める（$pos=1 なので1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', 1))->isSame('1...7890');
     * // 8文字に丸める（$pos=-1 なので後ろから1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', -1))->isSame('1234...0');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function str_ellipsis($string, $width, $trimmarker = '...', $pos = null)
    {
        $string = (string) $string;

        $strlen = mb_strlen($string);
        if ($strlen <= $width) {
            return $string;
        }

        $markerlen = mb_strlen($trimmarker);
        if ($markerlen >= $width) {
            return $trimmarker;
        }

        $length = $width - $markerlen;
        $pos ??= (int) ($length / 2);
        if ($pos < 0) {
            $pos += $length;
        }
        $pos = max(0, min($pos, $length));

        return mb_substr_replace($string, $trimmarker, $pos, $strlen - $length);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\str_embed') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\str_embed'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\str_embed')) {
    /**
     * エスケープ付きで文字列を置換する
     *
     * $replacemap で from -> to 文字列を指定する。
     * to は文字列と配列とクロージャを受け付ける。
     * 文字列の場合は普通に想起される動作で単純な置換となる。
     * 配列の場合は順次置換していく。要素が足りなくなったら例外を投げる。
     * クロージャの場合は(from, from 内の連番, トータル置換回数)でコールバックされる。null を返すと置換されない。
     *
     * strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。
     *
     * $enclosure で「特定文字に囲まれている」場合を無視することができる。
     * $escape で「特定文字が前にある」場合を無視することができる。
     *
     * Example:
     * ```php
     * // 最も単純な置換
     * that(str_embed('a, b, c', ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isSame('A, B, C');
     * // 最も長いキーから置換される
     * that(str_embed('abc', ['a' => 'X', 'ab' => 'AB']))->isSame('ABc');
     * // 配列を渡すと「N番目の置換」が実現できる（文字列の場合は再利用される）
     * that(str_embed('a, a, b, b', [
     *     'a' => 'A',          // 全ての a が A になる
     *     'b' => ['B1', 'B2'], // 1番目の b が B1, 2番目の b が B2 になる
     * ]))->isSame('A, A, B1, B2');
     * // クロージャを渡すと(from, from 内の連番, トータル置換回数)でコールバックされる
     * that(str_embed('a, a, b, b', [
     *     'a' => fn($src, $n, $l) => "$src,$n,$l",
     *     'b' => fn($src, $n, $l) => null,
     * ]))->isSame('a,0,0, a,1,1, b, b');
     * // 最も重要な性質として "' で囲まれていると対象にならない
     * that(str_embed('a, "a", b, "b", b', [
     *     'a' => 'A',
     *     'b' => ['B1', 'B2'],
     * ]))->isSame('A, "a", B1, "b", B2');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $replacemap 置換文字列
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?array $replaced 置換されたペアがタプルで格納される
     * @return string 置換された文字列
     */
    function str_embed($string, $replacemap, $enclosure = "'\"", $escape = '\\', &$replaced = null)
    {
        assert(is_iterable($replacemap));

        $string = (string) $string;

        // 長いキーから処理するためソートしておく
        $replacemap = arrayval($replacemap, false);
        uksort($replacemap, fn($a, $b) => strlen($b) - strlen($a));
        $srcs = array_keys($replacemap);

        $replaced = [];

        $counter = array_fill_keys(array_keys($replacemap), 0);
        for ($i = 0; $i < strlen($string); $i++) {
            $i = strpos_quoted($string, $srcs, $i, $enclosure, $escape);
            if ($i === false) {
                break;
            }

            foreach ($replacemap as $src => $dst) {
                $srclen = strlen($src);
                if ($srclen === 0) {
                    throw new \InvalidArgumentException("src length is 0.");
                }
                if (substr_compare($string, $src, $i, $srclen) === 0) {
                    $n = $counter[$src]++;
                    if ($dst instanceof \Closure) {
                        $dst = $dst($src, $n, count($replaced));
                        if ($dst === null) {
                            continue;
                        }
                    }
                    if (is_array($dst)) {
                        if (!isset($dst[$n])) {
                            throw new \InvalidArgumentException("notfound search string '$src' of {$n}th.");
                        }
                        $dst = $dst[$n];
                    }
                    $replaced[] = [$src, $dst];
                    $string = substr_replace($string, $dst, $i, $srclen);
                    $i += strlen($dst) - 1;
                    break;
                }
            }
        }
        return $string;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\str_exists') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\str_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\str_exists')) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists($haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        // あくまで文字列としての判定に徹する（strpos の第2引数は闇が深い気がする）
        $haystack = (string) $haystack;
        $needle = array_map('strval', $needle);

        foreach ($needle as $str) {
            if ($str === '') {
                continue;
            }
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\strpos_array') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\strpos_array'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\strpos_array')) {
    /**
     * 複数の文字列で strpos する
     *
     * $needles のそれぞれの位置を配列で返す。
     * ただし、見つからなかった文字は結果に含まれない。
     *
     * Example:
     * ```php
     * // 見つかった位置を返す
     * that(strpos_array('hello world', ['hello', 'world']))->isSame([
     *     0 => 0,
     *     1 => 6,
     * ]);
     * // 見つからない文字は含まれない
     * that(strpos_array('hello world', ['notfound', 'world']))->isSame([
     *     1 => 6,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param iterable $needles 位置を取得したい文字列配列
     * @param int $offset 開始位置
     * @return array $needles それぞれの位置配列
     */
    function strpos_array($haystack, $needles, $offset = 0)
    {
        if ($offset < 0) {
            $offset += strlen($haystack);
        }

        $result = [];
        foreach (arrayval($needles, false) as $key => $needle) {
            $pos = strpos($haystack, $needle, $offset);
            if ($pos !== false) {
                $result[$key] = $pos;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\strpos_quoted') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\strpos_quoted'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\strpos_quoted')) {
    /**
     * クオートを考慮して strpos する
     *
     * Example:
     * ```php
     * // クオート中は除外される
     * that(strpos_quoted('hello "this" is world', 'is'))->isSame(13);
     * // 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
     * that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))->isSame(20);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|iterable $needle 位置を取得したい文字列
     * @param int $offset 開始位置
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?string $found $needle の内、見つかった文字列が格納される
     * @return false|int $needle の位置
     */
    function strpos_quoted($haystack, $needle, $offset = 0, $enclosure = "'\"", $escape = '\\', &$found = null)
    {
        if (is_string($enclosure)) {
            if (strlen($enclosure)) {
                $chars = str_split($enclosure);
                $enclosure = array_combine($chars, $chars);
            }
            else {
                $enclosure = [];
            }
        }
        $needles = arrayval($needle, false);

        $strlen = strlen($haystack);

        if ($offset < 0) {
            $offset += $strlen;
        }

        $found = null;
        $enclosing = [];
        for ($i = $offset; $i < $strlen; $i++) {
            if ($i !== 0 && $haystack[$i - 1] === $escape) {
                continue;
            }
            foreach ($enclosure as $start => $end) {
                if (substr_compare($haystack, $end, $i, strlen($end)) === 0) {
                    if ($enclosing && $enclosing[count($enclosing) - 1] === $end) {
                        array_pop($enclosing);
                        $i += strlen($end) - 1;
                        continue 2;
                    }
                }
                if (substr_compare($haystack, $start, $i, strlen($start)) === 0) {
                    $enclosing[] = $end;
                    $i += strlen($start) - 1;
                    continue 2;
                }
            }

            if (empty($enclosing)) {
                foreach ($needles as $needle) {
                    if (substr_compare($haystack, $needle, $i, strlen($needle)) === 0) {
                        $found = $needle;
                        return $i;
                    }
                }
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\throws') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\throws'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\throws')) {
    /**
     * throw の関数版
     *
     * hoge() or throw などしたいことがまれによくあるはず。
     *
     * Example:
     * ```php
     * try {
     *     throws(new \Exception('throws'));
     * }
     * catch (\Exception $ex) {
     *     that($ex->getMessage())->isSame('throws');
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param \Exception $ex 投げる例外
     * @return mixed （`return hoge or throws` のようなコードで警告が出るので抑止用）
     */
    function throws($ex)
    {
        throw $ex;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\cache') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\cache'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\cache')) {
    /**
     * シンプルにキャッシュする
     *
     * この関数は get/set/delete を兼ねる。
     * キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。
     *
     * $provider に null を与えるとキャッシュの削除となる。
     *
     * Example:
     * ```php
     * $provider = fn() => rand();
     * // 乱数を返す処理だが、キャッシュされるので同じ値になる
     * $rand1 = cache('rand', $provider);
     * $rand2 = cache('rand', $provider);
     * that($rand1)->isSame($rand2);
     * // $provider に null を与えると削除される
     * cache('rand', null);
     * $rand3 = cache('rand', $provider);
     * that($rand1)->isNotSame($rand3);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param string $key キャッシュのキー
     * @param ?callable $provider キャッシュがない場合にコールされる callable
     * @param ?string $namespace 名前空間
     * @return mixed キャッシュ
     */
    function cache($key, $provider, $namespace = null)
    {
        static $cacheobject;
        $cacheobject ??= new class(function_configure('cachedir')) {
            const CACHE_EXT = '.php-cache';

            /** @var string キャッシュディレクトリ */
            private $cachedir;

            /** @var array 内部キャッシュ */
            private $cache;

            /** @var array 変更感知配列 */
            private $changed;

            public function __construct($cachedir)
            {
                $this->cachedir = $cachedir;
                $this->cache = [];
                $this->changed = [];
            }

            public function __destruct()
            {
                // 変更されているもののみ保存
                foreach ($this->changed as $namespace => $dummy) {
                    $filepath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    $content = "<?php\nreturn " . var_export($this->cache[$namespace], true) . ";\n";

                    $temppath = tempnam(sys_get_temp_dir(), 'cache');
                    if (file_put_contents($temppath, $content) !== false) {
                        @chmod($temppath, 0644);
                        if (!@rename($temppath, $filepath)) {
                            @unlink($temppath); // @codeCoverageIgnore
                        }
                    }
                }
            }

            public function has($namespace, $key)
            {
                // ファイルから読み込む必要があるので get しておく
                $this->get($namespace, $key);
                return array_key_exists($key, $this->cache[$namespace]);
            }

            public function get($namespace, $key)
            {
                // 名前空間自体がないなら作る or 読む
                if (!isset($this->cache[$namespace])) {
                    $nsarray = [];
                    $cachpath = $this->cachedir . '/' . rawurldecode($namespace) . self::CACHE_EXT;
                    if (file_exists($cachpath)) {
                        $nsarray = require $cachpath;
                    }
                    $this->cache[$namespace] = $nsarray;
                }

                return $this->cache[$namespace][$key] ?? null;
            }

            public function set($namespace, $key, $value)
            {
                // 新しい値が来たら変更フラグを立てる
                if (!isset($this->cache[$namespace]) || !array_key_exists($key, $this->cache[$namespace]) || $this->cache[$namespace][$key] !== $value) {
                    $this->changed[$namespace] = true;
                }

                $this->cache[$namespace][$key] = $value;
            }

            public function delete($namespace, $key)
            {
                $this->changed[$namespace] = true;
                unset($this->cache[$namespace][$key]);
            }

            public function clear()
            {
                // インメモリ情報をクリアして・・・
                $this->cache = [];
                $this->changed = [];

                // ファイルも消す
                foreach (glob($this->cachedir . '/*' . self::CACHE_EXT) as $file) {
                    unlink($file);
                }
            }
        };

        // flush (for test)
        if ($key === null) {
            if ($provider === null) {
                $cacheobject->clear();
            }
            $cacheobject = null;
            return;
        }

        $namespace ??= __FILE__;

        $exist = $cacheobject->has($namespace, $key);
        if ($provider === null) {
            $cacheobject->delete($namespace, $key);
            return $exist;
        }
        if (!$exist) {
            $cacheobject->set($namespace, $key, $provider());
        }
        return $cacheobject->get($namespace, $key);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\function_configure') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\function_configure'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\function_configure')) {
    /**
     * 本ライブラリの設定を行う
     *
     * 各関数の挙動を変えたり、デフォルトオプションを設定できる。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param array|string $option 設定。文字列指定時はその値を返す
     * @return array|string 設定値
     */
    function function_configure($option)
    {
        static $config = [];

        // default
        $config['cachedir'] ??= sys_get_temp_dir() . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['placeholder'] ??= '';
        $config['var_stream'] ??= get_cfg_var('rfunc.var_stream') ?: 'VarStreamV010000';          // for compatible
        $config['memory_stream'] ??= get_cfg_var('rfunc.memory_stream') ?: 'MemoryStreamV010000'; // for compatible
        $config['chain.version'] ??= 1;
        $config['chain.nullsafe'] ??= false;

        // setting
        if (is_array($option)) {
            foreach ($option as $name => $entry) {
                $option[$name] = $config[$name] ?? null;
                switch ($name) {
                    default:
                        $config[$name] = $entry;
                        break;
                    case 'cachedir':
                        $entry ??= $config[$name];
                        if (!file_exists($entry)) {
                            @mkdir($entry, 0777 & (~umask()), true);
                        }
                        $config[$name] = realpath($entry);
                        break;
                    case 'placeholder':
                        if (strlen($entry)) {
                            $entry = ltrim($entry[0] === '\\' ? $entry : __NAMESPACE__ . '\\' . $entry, '\\');
                            if (!defined($entry)) {
                                define($entry, tmpfile() ?: [] ?: '' ?: 0.0 ?: null ?: false);
                            }
                            if (!is_resource(constant($entry))) {
                                // もしリソースじゃないと一意性が保てず致命的になるので例外を投げる
                                throw new \RuntimeException('placeholder is not resource'); // @codeCoverageIgnore
                            }
                            $config[$name] = $entry;
                        }
                        break;
                }
            }
            return $option;
        }

        // getting
        if (is_string($option)) {
            switch ($option) {
                default:
                    return $config[$option] ?? null;
                case 'cachedir':
                    $dirname = $config[$option];
                    if (!file_exists($dirname)) {
                        @mkdir($dirname, 0777 & (~umask()), true); // @codeCoverageIgnore
                    }
                    return realpath($dirname);
            }
        }

        throw new \InvalidArgumentException(sprintf('$option is unknown type(%s)', gettype($option)));
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\arrayval') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\arrayval'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\arrayval')) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = stdclass(['key' => 'val']);
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\attr_exists') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\attr_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\attr_exists')) {
    /**
     * 配列・オブジェクトを問わずキーやプロパティの存在を確認する
     *
     * 配列が与えられた場合は array_key_exists と同じ。
     * オブジェクトは一旦 isset で確認した後 null の場合は実際にアクセスして試みる。
     *
     * Example:
     * ```php
     * $array = [
     *     'k' => 'v',
     *     'n' => null,
     * ];
     * // 配列は array_key_exists と同じ
     * that(attr_exists('k', $array))->isTrue();  // もちろん存在する
     * that(attr_exists('n', $array))->isTrue();  // isset ではないので null も true
     * that(attr_exists('x', $array))->isFalse(); // 存在しないので false
     *
     * $object = (object) $array;
     * // オブジェクトでも使える
     * that(attr_exists('k', $object))->isTrue();  // もちろん存在する
     * that(attr_exists('n', $object))->isTrue();  // isset ではないので null も true
     * that(attr_exists('x', $object))->isFalse(); // 存在しないので false
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param int|string $key 調べるキー
     * @param array|object $value 調べられる配列・オブジェクト
     * @return bool $key が存在するなら true
     */
    function attr_exists($key, $value)
    {
        return attr_get($key, $value, $dummy = new \stdClass()) !== $dummy;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\attr_get') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\attr_get'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\attr_get')) {
    /**
     * 配列・オブジェクトを問わずキーやプロパティの値を取得する
     *
     * 配列が与えられた場合は array_key_exists でチェック。
     * オブジェクトは一旦 isset で確認した後 null の場合は実際にアクセスして取得する。
     *
     * Example:
     * ```php
     * $array = [
     *     'k' => 'v',
     *     'n' => null,
     * ];
     * that(attr_get('k', $array))->isSame('v');                  // もちろん存在する
     * that(attr_get('n', $array))->isSame(null);                 // isset ではないので null も true
     * that(attr_get('x', $array, 'default'))->isSame('default'); // 存在しないのでデフォルト値
     *
     * $object = (object) $array;
     * // オブジェクトでも使える
     * that(attr_get('k', $object))->isSame('v');                  // もちろん存在する
     * that(attr_get('n', $object))->isSame(null);                 // isset ではないので null も true
     * that(attr_get('x', $object, 'default'))->isSame('default'); // 存在しないのでデフォルト値
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param int|string $key 取得するキー
     * @param array|object $value 取得される配列・オブジェクト
     * @param mixed $default なかった場合のデフォルト値
     * @return mixed $key の値
     */
    function attr_get($key, $value, $default = null)
    {
        if (is_array($value)) {
            // see https://www.php.net/manual/function.array-key-exists.php#107786
            return isset($value[$key]) || array_key_exists($key, $value) ? $value[$key] : $default;
        }

        if ($value instanceof \ArrayAccess) {
            // あるならあるでよい
            if (isset($value[$key])) {
                return $value[$key];
            }
            // 問題は「ない場合」と「あるが null だった場合」の区別で、ArrayAccess の実装次第なので一元的に確定するのは不可能
            // ここでは「ない場合はなんらかのエラー・例外が出るはず」という前提で実際に値を取得して確認する
            try {
                error_clear_last();
                $result = @$value[$key];
                return error_get_last() ? $default : $result;
            }
            catch (\Throwable $t) {
                return $default;
            }
        }

        // 上記のプロパティ版
        if (is_object($value)) {
            try {
                if (isset($value->$key)) {
                    return $value->$key;
                }
                error_clear_last();
                $result = @$value->$key;
                return error_get_last() ? $default : $result;
            }
            catch (\Throwable $t) {
                return $default;
            }
        }

        throw new \InvalidArgumentException(sprintf('%s must be array or object (%s).', '$value', var_type($value)));
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\is_arrayable') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\is_arrayable'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\is_arrayable')) {
    /**
     * 変数が配列アクセス可能か調べる
     *
     * Example:
     * ```php
     * that(is_arrayable([]))->isTrue();
     * that(is_arrayable(new \ArrayObject()))->isTrue();
     * that(is_arrayable(new \stdClass()))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 配列アクセス可能なら true
     */
    function is_arrayable($var)
    {
        return is_array($var) || $var instanceof \ArrayAccess;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\is_empty') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\is_empty'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\is_empty')) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\is_primitive') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\is_primitive'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\is_primitive')) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resource($var);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\is_stringable') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\is_stringable'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\is_stringable')) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\numval') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\numval'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\numval')) {
    /**
     * 値を数値化する
     *
     * int か float ならそのまま返す。
     * 文字列の場合、一言で言えば「.を含むなら float、含まないなら int」を返す。
     * int でも float でも stringable でもない場合は実装依存（ただの int キャスト）。
     *
     * Example:
     * ```php
     * that(numval(3.14))->isSame(3.14);   // int や float はそのまま返す
     * that(numval('3.14'))->isSame(3.14); // . を含む文字列は float を返す
     * that(numval('11', 8))->isSame(9);   // 基数が指定できる
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 数値化する値
     * @param int $base 基数。int 的な値のときしか意味をなさない
     * @return int|float 数値化した値
     */
    function numval($var, $base = 10)
    {
        if (is_int($var) || is_float($var)) {
            return $var;
        }
        if (is_object($var)) {
            $var = (string) $var;
        }
        if (is_string($var) && strpos($var, '.') !== false) {
            return (float) $var;
        }
        return intval($var, $base);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\si_unprefix') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\si_unprefix'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\si_unprefix')) {
    /**
     * SI 接頭辞が付与された文字列を数値化する
     *
     * 典型的な用途は ini_get で得られた値を数値化したいとき。
     * ただし、 ini は 1m のように小文字で指定することもあるので大文字化する必要はある。
     *
     * Example:
     * ```php
     * // 1k = 1000
     * that(si_unprefix('1k'))->isSame(1000);
     * // 1k = 1024
     * that(si_unprefix('1k', 1024))->isSame(1024);
     * // m はメガではなくミリ
     * that(si_unprefix('1m'))->isSame(0.001);
     * // M がメガ
     * that(si_unprefix('1M'))->isSame(1000000);
     * // K だけは特別扱いで大文字小文字のどちらでもキロになる
     * that(si_unprefix('1K'))->isSame(1000);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 数値化する値
     * @param int $unit 桁単位。実用上は 1000, 1024 の2値しか指定することはないはず
     * @return int|float SI 接頭辞を取り払った実際の数値
     */
    function si_unprefix($var, $unit = 1000)
    {
        assert($unit > 0);

        $var = trim($var);

        foreach (SI_UNITS as $exp => $sis) {
            foreach ($sis as $si) {
                if (strpos($var, $si) === (strlen($var) - strlen($si))) {
                    return numval($var) * pow($unit, $exp);
                }
            }
        }

        return numval($var);
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\stringify') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\stringify'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\stringify')) {
    /**
     * 値を何とかして文字列化する
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 文字列化する値
     * @return string $var を文字列化したもの
     */
    function stringify($var)
    {
        $type = gettype($var);
        switch ($type) {
            case 'NULL':
                return 'null';
            case 'boolean':
                return $var ? 'true' : 'false';
            case 'array':
                return var_export2($var, true);
            case 'object':
                if (method_exists($var, '__toString')) {
                    return (string) $var;
                }
                if (method_exists($var, '__serialize') || $var instanceof \Serializable) {
                    return serialize($var);
                }
                if ($var instanceof \JsonSerializable) {
                    return get_class($var) . ':' . json_encode($var, JSON_UNESCAPED_UNICODE);
                }
                return get_class($var);

            default:
                return (string) $var;
        }
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\var_export2') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\var_export2'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\var_export2')) {
    /**
     * 組み込みの var_export をいい感じにしたもの
     *
     * 下記の点が異なる。
     *
     * - 配列は 5.4 以降のショートシンタックス（[]）で出力
     * - インデントは 4 固定
     * - ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり
     * - 文字列はダブルクオート
     * - null は null（小文字）
     * - 再帰構造を渡しても警告がでない（さらに NULL ではなく `'*RECURSION*'` という文字列になる）
     * - 配列の再帰構造の出力が異なる（Example参照）
     *
     * Example:
     * ```php
     * // 単純なエクスポート
     * that(var_export2(['array' => [1, 2, 3], 'hash' => ['a' => 'A', 'b' => 'B', 'c' => 'C']], true))->isSame('[
     *     "array" => [1, 2, 3],
     *     "hash"  => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     * ]');
     * // 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
     * $rarray = [];
     * $rarray['a']['b']['c'] = &$rarray;
     * $robject = new \stdClass();
     * $robject->a = new \stdClass();
     * $robject->a->b = new \stdClass();
     * $robject->a->b->c = $robject;
     * that(var_export2(compact('rarray', 'robject'), true))->isSame('[
     *     "rarray"  => [
     *         "a" => [
     *             "b" => [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     *     "robject" => (object) [
     *         "a" => (object) [
     *             "b" => (object) [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     * ]');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param bool $return 返すなら true 出すなら false
     * @return string|null $return=true の場合は出力せず結果を返す
     */
    function var_export2($value, $return = false)
    {
        // インデントの空白数
        $INDENT = 4;

        // 再帰用クロージャ
        $export = function ($value, $nest = 0, $parents = []) use (&$export, $INDENT) {
            // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return $export('*RECURSION*');
                }
            }
            // 配列は連想判定したり再帰したり色々
            if (is_array($value)) {
                $spacer1 = str_repeat(' ', ($nest + 1) * $INDENT);
                $spacer2 = str_repeat(' ', $nest * $INDENT);

                $hashed = is_hasharray($value);

                // スカラー値のみで構成されているならシンプルな再帰
                if (!$hashed && array_all($value, fn(...$args) => is_primitive(...$args))) {
                    return '[' . implode(', ', array_map($export, $value)) . ']';
                }

                // 連想配列はキーを含めて桁あわせ
                if ($hashed) {
                    $keys = array_map($export, array_combine($keys = array_keys($value), $keys));
                    $maxlen = max(array_map('strlen', $keys));
                }
                $kvl = '';
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $keystr = $hashed ? $keys[$k] . str_repeat(' ', $maxlen - strlen($keys[$k])) . ' => ' : '';
                    $kvl .= $spacer1 . $keystr . $export($v, $nest + 1, $parents) . ",\n";
                }
                return "[\n{$kvl}{$spacer2}]";
            }
            // オブジェクトは単にプロパティを __set_state する文字列を出力する
            elseif (is_object($value)) {
                $parents[] = $value;
                $classname = get_class($value);
                if ($classname === \stdClass::class) {
                    return '(object) ' . $export((array) $value, $nest, $parents);
                }
                return $classname . '::__set_state(' . $export(get_object_properties($value), $nest, $parents) . ')';
            }
            // 文字列はダブルクオート
            elseif (is_string($value)) {
                return '"' . addcslashes($value, "\$\"\0\\") . '"';
            }
            // null は小文字で居て欲しい
            elseif (is_null($value)) {
                return 'null';
            }
            // それ以外は標準に従う
            else {
                return var_export($value, true);
            }
        };

        // 結果を返したり出力したり
        $result = $export($value);
        if ($return) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\var_hash') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\var_hash'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\var_hash')) {
    /**
     * 値に複数のハッシュアルゴリズムを適用させて結合して返す
     *
     * $data は何らかの方法で文字列化される（この「何らかの方法」は互換性を担保しない）。
     * 文字長がかなり増えるため、 $base64 に true を与えるとバイナリ変換してその結果を base64（url セーフ）して返す。
     * さらに false を与えると 16進数文字列で返し、 null を与えるとバイナリ文字列で返す。
     *
     * Example:
     * ```php
     * // 配列をハッシュ化する
     * that(var_hash(['a', 'b', 'c']))->isSame('7BDgx6NE2hkXAKtKzhpeJm6-mheMOQWNgrCe7768OiFeoWgA');
     * // オブジェクトをハッシュ化する
     * that(var_hash(new \ArrayObject(['a', 'b', 'c'])))->isSame('-zR2rZ58CzuYhhdHn1Oq90zkYSaxMS-dHUbmb0MTRM4gBpj2');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var ハッシュ化する値
     * @param string[] $algos ハッシュアルゴリズム
     * @param ?bool $base64 結果を base64 化するか
     * @return string ハッシュ文字列
     */
    function var_hash($var, $algos = ['md5', 'sha1'], $base64 = true)
    {
        if (!is_string($var)) {
            $var = serialize($var);
        }

        $algos = arrayize($algos);
        assert($algos);

        $hash = '';
        foreach ($algos as $algo) {
            $hash .= hash($algo, "$var", $base64 !== false);
        }

        if ($base64 !== true) {
            return $hash;
        }

        return rtrim(strtr(base64_encode($hash), ['+' => '-', '/' => '_']));
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\var_pretty') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\var_pretty'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\var_pretty')) {
    /**
     * var_dump の出力を見やすくしたもの
     *
     * var_dump はとても縦に長い上見づらいので色や改行・空白を調整して見やすくした。
     * sapi に応じて自動で色分けがなされる（$context で指定もできる）。
     * また、 xdebug のように呼び出しファイル:行数が先頭に付与される。
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * Example:
     * ```php
     * // 下記のように出力される（実際は色付きで出力される）
     * $using = 123;
     * var_pretty([
     *     "array"   => [1, 2, 3],
     *     "hash"    => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     *     "object"  => new \Exception(),
     *     "closure" => function () use ($using) { },
     * ]);
     * ?>
     * {
     *   array: [1, 2, 3],
     *   hash: {
     *     a: 'A',
     *     b: 'B',
     *     c: 'C',
     *   },
     *   object: Exception#1 {
     *     message: '',
     *     string: '',
     *     code: 0,
     *     file: '...',
     *     line: 19,
     *     trace: [],
     *     previous: null,
     *   },
     *   closure: Closure#0(static) use {
     *     using: 123,
     *   },
     * }
     * <?php
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param array $options 出力オプション
     * @return string return: true なら値の出力結果
     */
    function var_pretty($value, $options = [])
    {
        $options += [
            'minify'        => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent'        => 2,     // インデントの空白数
            'context'       => null,  // html なコンテキストか cli なコンテキストか
            'return'        => false, // 値を戻すか出力するか
            'trace'         => false, // スタックトレースの表示
            'callback'      => null,  // 値1つごとのコールバック（値と文字列表現（参照）が引数で渡ってくる）
            'debuginfo'     => true,  // debugInfo を利用してオブジェクトのプロパティを絞るか
            'table'         => true,  // 連想配列の配列の場合にテーブル表示するか（コールバック。true はマークダウン風味固定）
            'maxcolumn'     => null,  // 1行あたりの文字数
            'maxcount'      => null,  // 複合型の要素の数
            'maxdepth'      => null,  // 複合型の深さ
            'maxlength'     => null,  // スカラー・非複合配列の文字数
            'maxlistcolumn' => 120,   // 通常配列を1行化する文字数
            'limit'         => null,  // 最終出力の文字数
            'excludeclass'  => [],    // 除外するクラス名
        ];

        if ($options['context'] === null) {
            $options['context'] = 'html'; // SAPI でテストカバレッジが辛いので if else ではなくデフォルト代入にしてある
            if (PHP_SAPI === 'cli') {
                $options['context'] = is_ansi(STDOUT) && !$options['return'] ? 'cli' : 'plain';
            }
        }

        if ($options['minify']) {
            $options['indent'] = null;
            $options['trace'] = false;
        }

        $appender = new class($options) {
            private $options;
            private $objects;
            private $content;
            private $length;
            private $column;

            public function __construct($options)
            {
                $this->options = $options;
                $this->objects = [];
                $this->content = '';
                $this->length = 0;
                $this->column = 0;
            }

            private function _append($value, $style = null, $data = []): self
            {
                if ($this->options['minify']) {
                    $value = strtr($value, ["\n" => ' ']);
                }

                $strlen = strlen($value);

                if ($this->options['limit'] && $this->options['limit'] < $this->length += $strlen) {
                    throw new \LengthException($this->content);
                }

                //$current = count($this->content) - 1;
                if ($this->options['maxcolumn'] !== null) {
                    $breakpos = strrpos($value, "\n");
                    if ($breakpos === false) {
                        $this->column += $strlen;
                    }
                    else {
                        $this->column = $strlen - $breakpos - 1;
                    }
                    if ($this->column >= $this->options['maxcolumn']) {
                        preg_match('# +#', $this->content, $m, 0, strrpos($this->content, "\n"));
                        $this->column = 0;
                        $this->content .= "\n\t" . $m[0];
                    }
                }

                if ($style === null || $this->options['context'] === 'plain') {
                    $this->content .= $value;
                }
                elseif ($this->options['context'] === 'cli') {
                    $this->content .= ansi_colorize($value, $style);
                }
                elseif ($this->options['context'] === 'html') {
                    // 今のところ bold しか使っていないのでこれでよい
                    $style = $style === 'bold' ? 'font-weight:bold' : "color:$style";
                    $dataattr = array_sprintf($data, 'data-%2$s="%1$s"', ' ');
                    $this->content .= "<span style='$style' $dataattr>" . htmlspecialchars($value, ENT_QUOTES) . '</span>';
                }
                else {
                    throw new \InvalidArgumentException("'{$this->options['context']}' is not supported.");
                }
                return $this;
            }

            public function plain($token, $style = null): self
            {
                return $this->_append($token, $style);
            }

            public function index($token): self
            {
                if (is_int($token)) {
                    return $this->_append($token, 'bold');
                }
                elseif (is_string($token)) {
                    return $this->_append($token, 'red');
                }
                elseif (is_object($token)) {
                    return $this->_append($this->string($token), 'green', ['type' => 'object-index', 'id' => spl_object_id($token)]);
                }
                else {
                    throw new \DomainException(); // @codeCoverageIgnore
                }
            }

            public function value($token): self
            {
                if (is_null($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'null']);
                }
                elseif (is_object($token)) {
                    return $this->_append($this->string($token), 'green', ['type' => 'object', 'id' => spl_object_id($token)]);
                }
                elseif (is_resource($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'resource']);
                }
                elseif (is_string($token)) {
                    return $this->_append($this->string($token), 'magenta', ['type' => 'scalar']);
                }
                elseif (is_bool($token)) {
                    return $this->_append($this->string($token), 'bold', ['type' => 'bool']);
                }
                elseif (is_scalar($token)) {
                    return $this->_append($this->string($token), 'magenta', ['type' => 'scalar']);
                }
                else {
                    throw new \DomainException(); // @codeCoverageIgnore
                }
            }

            public function string($token): string
            {
                if (is_null($token)) {
                    return 'null';
                }
                elseif (is_object($token)) {
                    if ($token instanceof \Closure) {
                        $ref = new \ReflectionFunction($token);
                        $fname = $ref->getFileName();
                        $sline = $ref->getStartLine();
                        $eline = $ref->getEndLine();
                        if ($fname && $sline && $eline) {
                            $lines = $sline === $eline ? $sline : "$sline~$eline";
                            return get_class($token) . "@$fname:$lines#" . spl_object_id($token);
                        }
                    }
                    return get_class($token) . "#" . spl_object_id($token);
                }
                elseif (is_resource($token)) {
                    return sprintf('%s of type (%s)', $token, get_resource_type($token));
                }
                elseif (is_string($token)) {
                    if ($this->options['maxlength']) {
                        $token = str_ellipsis($token, $this->options['maxlength'], '...(too length)...');
                    }
                    return json_encode($token, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
                }
                elseif (is_scalar($token)) {
                    return var_export($token, true);
                }
                else {
                    throw new \DomainException(gettype($token)); // @codeCoverageIgnore
                }
            }

            public function array($value): array
            {
                if (is_array($value)) {
                    return $value;
                }
                if (is_object($value)) {
                    if ($this->options['debuginfo'] && method_exists($value, '__debugInfo')) {
                        $properties = [];
                        foreach (array_reverse($value->__debugInfo(), true) as $k => $v) {
                            $p = strrpos($k, "\0");
                            if ($p !== false) {
                                $k = substr($k, $p + 1);
                            }
                            $properties[$k] = $v;
                        }
                    }
                    else {
                        $properties = get_object_properties($value);
                    }
                    return $properties;
                }
            }

            public function export($value, $nest, $parents, $keys, $callback)
            {
                $position = strlen($this->content);

                // オブジェクトは一度処理してれば無駄なので参照表示
                if (is_object($value)) {
                    $id = spl_object_id($value);
                    if (isset($this->objects[$id])) {
                        $this->index($value);
                        goto FINALLY_;
                    }
                    $this->objects[$id] = $value;
                }

                // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
                foreach ($parents as $parent) {
                    if ($parent === $value) {
                        $this->plain('*RECURSION*');
                        goto FINALLY_;
                    }
                }

                if (is_array($value)) {
                    if ($this->options['maxdepth'] && $nest + 1 > $this->options['maxdepth']) {
                        $this->plain('(too deep)');
                        goto FINALLY_;
                    }

                    $parents[] = $value;

                    $count = count($value);
                    $omitted = false;
                    if ($this->options['maxcount'] && ($omitted = $count - $this->options['maxcount']) > 0) {
                        $value = array_slice($value, 0, $this->options['maxcount'], true);
                    }

                    $is_hasharray = is_hasharray($value);
                    $primitive_only = array_all($value, fn(...$args) => is_primitive(...$args));
                    $assoc = !$this->options['minify'] && ($is_hasharray || !$primitive_only);
                    $tableofarray = (function () use ($count, $value) {
                        if ($this->options['minify'] || !$this->options['table'] || $count <= 1) {
                            return null;
                        }

                        $first = reset($value);
                        $objective = is_object($first);
                        if ((!is_array($first) && !$objective) || empty($first)) {
                            return null;
                        }

                        // オブジェクトの一致性は完全同一クラス（継承や実装は見ない）、配列はキーが同じものとする
                        if ($objective) {
                            $first_condition = get_class($first);
                        }
                        else {
                            $first_condition = array_keys($first);
                            if (array_any($first_condition, 'is_int')) {
                                return null;
                            }
                        }

                        foreach ($value as $v) {
                            if (true
                                && !(is_array($v) && array_keys($v) === $first_condition)
                                && !(is_object($v) && get_class($v) === $first_condition)
                            ) {
                                return null;
                            }
                        }

                        return $objective ? "{$first_condition}[]" : 'array[]';
                    })();

                    $spacer1 = $this->options['indent'] === null ? '' : str_repeat(' ', ($nest + 1) * $this->options['indent']);
                    $spacer2 = $this->options['indent'] === null ? '' : str_repeat(' ', ($nest + 0) * $this->options['indent']);

                    $key = null;
                    if ($primitive_only) {
                        $lengths = [];
                        foreach ($value as $k => $v) {
                            if ($assoc) {
                                $lengths[] = strlen($this->string($spacer1)) + strlen($this->string($k)) + strlen($this->string($v)) + 4;
                            }
                            else {
                                $lengths[] = strlen($this->string($v)) + 2;
                            }
                        }
                        if ($this->options['maxlength']) {
                            while (count($lengths) > 0 && array_sum($lengths) > $this->options['maxlength']) {
                                $middle = (int) (count($lengths) / 2);
                                $unpos = fn($v, $k, $n) => $n === $middle;
                                array_unset($value, $unpos);
                                array_unset($lengths, $unpos);
                                $key = (int) (count($lengths) / 2);
                            }
                        }
                        // 要素が1つなら複数行化するメリットがないので2以上とする
                        if (count($lengths) >= 2 && ($this->options['maxlistcolumn'] ?? PHP_INT_MAX) <= array_sum($lengths)) {
                            $assoc = !$this->options['minify'] && true;
                        }
                    }

                    if ($count === 0) {
                        $this->plain('[]');
                    }
                    elseif ($tableofarray) {
                        $this->plain($tableofarray, 'green');
                        $this->plain("\n");
                        if ($this->options['table'] === true) {
                            $this->plain(preg_replace('#^#um', $spacer1, markdown_table(array_map(fn($v) => $this->array($v), $value), [
                                'keylabel' => "#",
                                'context'  => $this->options['context'],
                            ])));
                        }
                        else {
                            $this->plain(($this->options['table'])(array_map(fn($v) => $this->array($v), $value), $nest));
                        }
                        $this->plain($spacer2);
                    }
                    elseif ($assoc) {
                        $n = 0;
                        if ($is_hasharray) {
                            $this->plain("{\n");
                        }
                        else {
                            $this->plain("[\n");
                        }
                        if (!$value) {
                            $this->plain($spacer1)->plain('...(too length)...')->plain(",\n");
                        }
                        foreach ($value as $k => $v) {
                            if ($key === $n++) {
                                $this->plain($spacer1)->plain('...(too length)...')->plain(",\n");
                            }
                            $this->plain($spacer1);
                            if ($is_hasharray) {
                                $this->index($k)->plain(': ');
                            }
                            $this->export($v, $nest + 1, $parents, array_merge($keys, [$k]), true);
                            $this->plain(",\n");
                        }
                        if ($omitted > 0) {
                            $this->plain("$spacer1(more $omitted elements)\n");
                        }
                        if ($is_hasharray) {
                            $this->plain("{$spacer2}}");
                        }
                        else {
                            $this->plain("{$spacer2}]");
                        }
                    }
                    else {
                        $lastkey = last_key($value);
                        $n = 0;
                        $this->plain('[');
                        if (!$value) {
                            $this->plain('...(too length)...')->plain(', ');
                        }
                        foreach ($value as $k => $v) {
                            if ($key === $n) {
                                $this->plain('...(too length)...')->plain(', ');
                            }
                            if ($is_hasharray && $n !== $k) {
                                $this->index($k)->plain(':');
                            }
                            $this->export($v, $nest, $parents, array_merge($keys, [$k]), true);
                            if ($k !== $lastkey) {
                                $this->plain(', ');
                            }
                            $n++;
                        }
                        if ($omitted > 0) {
                            $this->plain(" (more $omitted elements)");
                        }
                        $this->plain(']');
                    }
                }
                elseif ($value instanceof \Closure) {
                    $this->value($value);

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    $ref = reflect_callable($value);
                    $that = $ref->getClosureThis();
                    $properties = $ref->getStaticVariables();

                    $this->plain("(");
                    if ($that) {
                        $this->index($that);
                    }
                    else {
                        $this->plain("static");
                    }
                    $this->plain(') use ');
                    if ($properties) {
                        $this->export($properties, $nest, $parents, $keys, false);
                    }
                    else {
                        $this->plain('{}');
                    }
                }
                elseif (is_object($value)) {
                    $this->value($value);

                    foreach ((array) $this->options['excludeclass'] as $class) {
                        if ($value instanceof $class) {
                            goto FINALLY_;
                        }
                    }

                    if ($this->options['minify']) {
                        goto FINALLY_;
                    }

                    $properties = $this->array($value);

                    $this->plain(" ");
                    if ($properties) {
                        $this->export($properties, $nest, $parents, $keys, false);
                    }
                    else {
                        $this->plain('{}');
                    }
                }
                else {
                    $this->value($value);
                }

                FINALLY_:
                $content = substr($this->content, $position);
                if ($callback && $this->options['callback']) {
                    ($this->options['callback'])($content, $value, $nest, $keys);
                    $this->content = substr_replace($this->content, $content, $position);
                }
                return $content;
            }
        };

        try {
            $content = $appender->export($value, 0, [], [], false);
        }
        catch (\LengthException $ex) {
            $content = $ex->getMessage() . '(...omitted)';
        }

        if ($options['callback']) {
            ($options['callback'])($content, $value, 0, []);
        }

        // 結果を返したり出力したり
        $traces = [];
        if ($options['trace']) {
            $traces = stacktrace(null, ['format' => "%s:%s", 'args' => false, 'delimiter' => null]);
            $traces = array_reverse(array_slice($traces, 0, $options['trace'] === true ? null : $options['trace']));
            $traces[] = '';
        }
        $result = implode("\n", $traces) . $content;

        if ($options['context'] === 'html') {
            $result = "<pre class='var_pretty'>$result</pre>";
        }
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\WebDebugger\\var_type') || (new \ReflectionFunction('ryunosuke\\WebDebugger\\var_type'))->isUserDefined());
if (!function_exists('ryunosuke\\WebDebugger\\var_type')) {
    /**
     * 値の型を取得する（gettype + get_class）
     *
     * プリミティブ型（gettype で得られるやつ）はそのまま、オブジェクトのときのみクラス名を返す。
     * ただし、オブジェクトの場合は先頭に '\\' が必ず付く。
     * また、 $valid_name を true にするとタイプヒントとして正当な名前を返す（integer -> int, double -> float など）。
     * 互換性のためデフォルト false になっているが、将来的にこの引数は削除されるかデフォルト true に変更される。
     *
     * 無名クラスの場合は extends, implements の優先順位でその名前を使う。
     * 継承も実装もされていない場合は標準の get_class の結果を返す。
     *
     * Example:
     * ```php
     * // プリミティブ型は gettype と同義
     * that(var_type(false))->isSame('boolean');
     * that(var_type(123))->isSame('integer');
     * that(var_type(3.14))->isSame('double');
     * that(var_type([1, 2, 3]))->isSame('array');
     * // オブジェクトは型名を返す
     * that(var_type(new \stdClass))->isSame('\\stdClass');
     * that(var_type(new \Exception()))->isSame('\\Exception');
     * // 無名クラスは継承元の型名を返す（インターフェース実装だけのときはインターフェース名）
     * that(var_type(new class extends \Exception{}))->isSame('\\Exception');
     * that(var_type(new class implements \JsonSerializable{
     *     public function jsonSerialize(): string { return ''; }
     * }))->isSame('\\JsonSerializable');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 型を取得する値
     * @param bool $valid_name タイプヒントとして有効な名前を返すか
     * @return string 型名
     */
    function var_type($var, $valid_name = false)
    {
        if (is_object($var)) {
            $ref = new \ReflectionObject($var);
            if ($ref->isAnonymous()) {
                if ($pc = $ref->getParentClass()) {
                    return '\\' . $pc->name;
                }
                if ($is = $ref->getInterfaceNames()) {
                    return '\\' . reset($is);
                }
            }
            return '\\' . get_class($var);
        }
        $type = gettype($var);
        if (!$valid_name) {
            return $type;
        }
        switch ($type) {
            default:
                return $type;
            case 'NULL':
                return 'null';
            case 'boolean':
                return 'bool';
            case 'integer':
                return 'int';
            case 'double':
                return 'float';
        }
    }
}
